<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构之线性表</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表是一种最基本的数据结构，下面是线性表的顺序存储方式（以下代码均参考《大话数据结构》，运行环境dev c++5.11）  </p><pre><code>#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define MAXSIZE 100
typedef int ElementType;
typedef struct LNode *List;
struct LNode{
ElementType Data[MAXSIZE];
int Last;
}; 
List L;

List MakeEmpty();
int Find(ElementType X,List L);
void Insert(ElementType X,int i,List L);
void Delete(int i,List L);
ElementType FindKth(int K,List L);

//初始化
List MakeEmpty(){
List L;
L=(List)malloc(sizeof(struct LNode));
L-&gt;Last=-1;
return L;
}
//按值查找 
int Find(ElementType X,List L){
int i=0;
while(i&lt;=L-&gt;Last&amp;&amp;L-&gt;Data[i]!=X)
    i++;
if(L-&gt;Last&lt;i)
    return -1;
    else 
    return i;
}

//插入,下面的为头插法 
void Insert(ElementType X,int i,List L){
int j;
if(L-&gt;Last==MAXSIZE-1){
    printf(&quot;表满&quot;);
    return;
}
if(i&lt;0||L-&gt;Last+1&lt;i){
    printf(&quot;位置不合法&quot;);
    return; 
}
for(j=L-&gt;Last;j&gt;=i;j--)
    L-&gt;Data[j+1]=L-&gt;Data[j];
    L-&gt;Data[i]=X;
    L-&gt;Last++;
    return;
} 

void Delete(int i,List L){
int j;
if(i&lt;0||L-&gt;Last&lt;i){
    printf(&quot;L-&gt;Data[%d]不存在元素&quot;,i);
    return;
}
for(j=i;j&lt;L-&gt;Last;j++)//删除第i个元素，实际上对应的下标是i-1 
    L-&gt;Data[j-1]=L-&gt;Data[j];
    L-&gt;Last--;
    return; 
}
ElementType FindKth(int K,List L){
if(K&lt;0||L-&gt;Last&lt;K){
    printf(&quot;L-&gt;Data[%d]不存在元素&quot;,K);
    return;
}
return L-&gt;Data[K];
}
int Length(List L){
return L-&gt;Last+1;
}
int main(){
int i=0;
L=MakeEmpty();
Insert(11,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入11\n&quot;);
Insert(25,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入25\n&quot;);
Insert(33,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入33\n&quot;);
Insert(77,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入77\n&quot;);
printf(&quot;此时线性表为；&quot;);
for(i=0;i&lt;Length(L);i++)
    printf(&quot;%d&quot;,L-&gt;Data[i]);
printf(&quot;\n&quot;);
printf(&quot;查找值为12的下标为：%d\n&quot;,Find(12,L));
printf(&quot;下标为3的线性表的值是：%d\n&quot;,FindKth(3,L));
Delete(2,L);
printf(&quot;删除下标为2的元素\n&quot;); 
Delete(2,L);
printf(&quot;删除下标为2的元素\n&quot;);  
    printf(&quot;此时线性表为；&quot;);
for(i=0;i&lt;Length(L);i++)
    printf(&quot;%d&quot;,L-&gt;Data[i]);
printf(&quot;\n&quot;);
return 0;
}  </code></pre><a id="more"></a>
<p>以下是线性表的链式存储结构  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
typedef int ElementType;
typedef struct LNode *List;
struct LNode{
ElementType Data;
List Next;
};
List L;
List MakeEmpty();
int Length(List);
List FindfKth(int K,List L);
List Find(ElementType X,List L);
List Insert(ElementType X,int i,List L);
List Delete(int i,List L);
void Print(List L);

List MakeEmpty(){
List L=(List)malloc(sizeof(struct LNode));
L=NULL;
return L;
}

int Length(List L){
List p=L;
int len=0;
while(p){
    p=p-&gt;Next;
    len++;
}
return len;
}
List FindKth(int K,List L){
List p=L;
int i=1;
while(p&amp;&amp;i&lt;K){
    p=p-&gt;Next;
    i++;
}
if(i==K)
    return p;
else
    return NULL;
}
List Find(ElementType X,List L){
List p=L;
while(p&amp;&amp;p-&gt;Data!=X)
    p=p-&gt;Next;
return p;
}
List Insert(ElementType X,int i,List L){
List p,s;
if(i==1){
    s=(List)malloc(sizeof(struct LNode));
    s-&gt;Data=X;
    s-&gt;Next=L;
    return s;
}
p=FindKth(i-1,L);
if(!p){
    printf(&quot;结点错误&quot;);
    return NULL; 
}else{
    s=(List)malloc(sizeof(struct LNode));
    s-&gt;Data=X;
    s-&gt;Next=p-&gt;Next;
    p-&gt;Next=s;
    return L;
}
}
List Delete(int i,List L){
List p,s;
if(i==1){
    s=L;
    if(L)
        L=L-&gt;Next;
    else
        return NULL;
    free(s);
    return L;
}
p=FindKth(i-1,L);
if(!p||!(p-&gt;Next)){
    printf(&quot;结点错误&quot;);
    return NULL; 
}else{
    s=p-&gt;Next;
    p-&gt;Next=s-&gt;Next;
    free(s);
    return L;
}
}
void Print(List L){
List t;
int flag=1;
printf(&quot;当前链表为：&quot;);
for(t=L;t;t=t-&gt;Next){
    printf(&quot;%d&quot;,t-&gt;Data);
    flag=0;
} if(flag)
    printf(&quot;NULL&quot;);
printf(&quot;\n&quot;);
}
int main(){
L=MakeEmpty();
Print(L);
L=Insert(11,1,L);
L=Insert(25,1,L);
L=Insert(32,1,L);
L=Insert(77,1,L);
Print(L);
printf(&quot;当前链表长度：%d\n&quot;,Length(L));
printf(&quot;当前链表中第二个结点的值是：%d\n&quot;,FindKth(2,L)-&gt;Data);
printf(&quot;查询22是否在该链表中：&quot;);
if(Find(22,L))
    printf(&quot;是\n&quot;);
else
    printf(&quot;否\n&quot;);
printf(&quot;查询33是否在该链表中：&quot;);
if(Find(33,L))
    printf(&quot;是\n&quot;);
else
    printf(&quot;否\n&quot;);
L=Delete(1,L);
L=Delete(3,L);
printf(&quot;------------删除后---------\n&quot;);
Print(L);
return 0; 

}</code></pre><p>以下是栈的链式存储结构  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType;

//链栈的结构,也可参考线性表的链式存储，效果是一样的 
typedef struct StackNode{//定义结点 
SElemType data;
struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct {//定义一个栈 
LinkStackPtr top;//定义了一个指向结点的指针
int count; 
}LinkStack;

Status visit(SElemType c){
printf(&quot;%d &quot;, c);
return OK;
} 

//构造一个空栈
Status InitStack(LinkStack *S){
S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));
if(!S-&gt;top)
    return ERROR;
    S-&gt;top = NULL;
    S-&gt;count = 0;
    return OK;
} 

//把S置为空栈
Status ClearStack(LinkStack *S){
LinkStackPtr p, q;//定义两个指向结点的指针 
p = S-&gt;top;
while(p){
    q = p;
    p = p-&gt;next;
    free(q);
}
S-&gt;count = 0;
return OK; 
} 

//判断是否为空
Status StackEmpty(LinkStack S){
if(S.count == 0)
    return TRUE;
else 
    return FALSE;
} 

//返回栈的长度
int StackLength(LinkStack S){
return S.count; 
} 

//用e返回栈顶元素
Status GetTop(LinkStack S, SElemType *e){
if(S.top == NULL)
    return ERROR;
else
    *e = S.top-&gt;data;
return OK;
} 

//插入元素为e的栈顶元素
Status Push(LinkStack *S, SElemType e){
LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
s-&gt;data = e;
s-&gt;next = S-&gt;top;
S-&gt;top = s;
S-&gt;count++;
return OK;
} 

//删除栈顶的元素，并用e返回
Status Pop(LinkStack *S, SElemType *e){
LinkStackPtr p;//先找结点再删除 
if(StackEmpty(*S))
    return ERROR;
*e = S-&gt;top-&gt;data;
p = S-&gt;top;
S-&gt;top = S-&gt;top-&gt;next;
free(p);
S-&gt;count--;
return OK; 
} 

//从顶开始访问
Status StackTraverse(LinkStack S){
LinkStackPtr p;
p=S.top;
while(p){
    visit(p-&gt;data);
    p = p-&gt;next;
}
printf(&quot;\n&quot;);
return OK;
} 

int main(){
int j;
LinkStack s;
int e;
if(InitStack(&amp;s) == OK)
    for(j = 1; j &lt;= 10; j++)
        Push(&amp;s, j);
printf(&quot;栈中元素依次为: &quot;);
StackTraverse(s);
Pop(&amp;s, &amp;e);
printf(&quot;弹出栈顶元素 e = %d\n&quot;,e);
printf(&quot;栈空否: %d(1:空 0:否)\n&quot;,StackEmpty(s));
GetTop(s,&amp;e);
printf(&quot;栈顶元素 e = %d 栈的长度为%d\n&quot;, e,StackLength(s));
ClearStack(&amp;s);
printf(&quot;清空后，栈空否: %d(1:空 0:否)\n&quot;,StackEmpty(s));
return 0;
}  </code></pre><p>以下是斐波那契数列的两种计算方法，注意体会迭代和递归的含义，当使用递归的方法的时候，对计算机内存的占用是非常大的  </p>
<pre><code>#include&lt;stdio.h&gt;

int F(int i){
if(i &lt; 2)
    return i == 0 ? 0 : 1;
return F(i - 1) + F(i - 2); 
}
int main(){
int i;
int a[40];
printf(&quot;迭代显示斐波那契数列：\n&quot;);
a[0] = 0;
a[1] = 1;
printf(&quot;%d &quot;, a[0]);
printf(&quot;%d &quot;, a[1]);
for(i = 2; i &lt; 40; i++){
    a[i] = a[i - 1] + a[i -2];
    printf(&quot;%d &quot;, a[i]);
} 
printf(&quot;\n&quot;);

printf(&quot;递归显示斐波那契数列：\n&quot;);
for(i = 0; i &lt; 40; i++)
    printf(&quot;%d &quot;, F(i));
return 0;
} </code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之栈</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88/</url>
    <content><![CDATA[<p>栈是一种后进先出（LIFO)的数据结构，下面是栈的顺序存储方式  </p><pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType; 

//顺序栈结构
typedef struct{
SElemType data[MAXSIZE];
int top;
}SqStack; 

Status visit(SElemType c){
printf(&quot;%d &quot;,c);
return OK;
}

//构造一个空栈 
Status InitStack(SqStack *S){
S-&gt;top=-1;
return OK;
} 

//把S置为空栈
Status ClearStack(SqStack *S){
S-&gt;top=-1;
return OK;
} 

//判断是否为空栈
Status StackEmpty(SqStack S){
if(S.top==-1)
    return TRUE;
else 
    return FALSE;
} 

//返回栈的长度
int StackLength(SqStack S){
return S.top+1;
} 

//若栈不空，用e返回栈顶元素，并返回OK,否则返回ERROR
Status GetTop(SqStack S,SElemType *e){
if(S.top==-1)
    return ERROR;
else
    *e=S.data[S.top];
return OK; 
} 

//插入元素e为新的栈顶元素
Status Push(SqStack *S,SElemType e){
if(S-&gt;top==MAXSIZE-1)
{
    return ERROR;
}
S-&gt;top++;
S-&gt;data[S-&gt;top]=e;
return OK;
} 

//删除栈顶元素
Status Pop(SqStack *S,SElemType *e){
if(S-&gt;top==-1)
    return ERROR;
else{
    *e=S-&gt;data[S-&gt;top];
    S-&gt;top--;
return OK;     
} 
} 

//从栈底到栈顶以此对每一个元素进行显示
Status StackTraverse(SqStack S){
int i;
i=0;
while(i&lt;=S.top){
    visit(S.data[i++]);
}
printf(&quot;\n&quot;);
return OK; 
} 

int main(){
int j;
SqStack s;
int e;
if(InitStack(&amp;s)==OK)//判断一下更把握 
    for(j=1;j&lt;=10;j++)
        Push(&amp;s,j);
printf(&quot;栈中元素以此为： &quot;);
StackTraverse(s);
Pop(&amp;s,&amp;e);//e用来返回弹出的值
printf(&quot;弹出的栈顶元素为e=%d\n&quot;,e);
printf(&quot;栈是否空：%d(1:空 0:不空)\n&quot;,StackEmpty(s));
GetTop(s,&amp;e);
printf(&quot;栈顶元素为e=%d 栈的长度为%d\n&quot;,e,StackLength(s));
ClearStack(&amp;s);
printf(&quot;栈清空后，栈是否空：%d(:空 0:不空)&quot;,StackEmpty(s));
}</code></pre><a id="more"></a>
<p>下面是两个栈共享空间的情况：  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType; 

//两栈共享空间
typedef struct{
SElemType data[MAXSIZE];
int top1;
int top2;
}SqDoubleStack;

Status visit(SElemType c){
printf(&quot;%d &quot;,c);
return OK; 
}
//构造一个空栈
Status InitStack(SqDoubleStack *S){
S-&gt;top1=-1;
S-&gt;top2=MAXSIZE;
return OK; 
} 

//把S置为空栈；和上面的构造一个空栈代码是一样的 
Status ClearStack(SqDoubleStack *S){
S-&gt;top1=-1;
S-&gt;top2=MAXSIZE;
return OK;
} 

//判断是否为空栈;两个要都为空 
Status StackEmpty(SqDoubleStack S){
if(S.top1==-1&amp;&amp;S.top2==MAXSIZE)
    return TRUE;
else
    return FALSE;
} 

//返回元素个数，即栈长
int StackLength(SqDoubleStack S){
return (S.top1+1)+(MAXSIZE-S.top2);
} 

//插入元素，需要标记是往哪个里面push,只需要判断总的栈是否满 
Status Push(SqDoubleStack *S,SElemType e,int stackNumber){
if(S-&gt;top1+1==S-&gt;top2)
    return ERROR;
if(stackNumber==1)
    S-&gt;data[++S-&gt;top1]=e;
else if(stackNumber==2)
    S-&gt;data[--S-&gt;top2]=e;
return OK;
} 

//删除栈顶的元素，需要分别判断每个是否为空 
Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber){
if(stackNumber==1){
    if(S-&gt;top1==-1)
        return ERROR;
    *e=S-&gt;data[S-&gt;top1--];//相当于两个语句，一个是把栈顶元素返回，一个是指针指向前一个 
} 
else if(stackNumber==2){
    if(S-&gt;top2==MAXSIZE)
        return ERROR;
    *e=S-&gt;data[S-&gt;top2++];
} 
return OK;
} 

//从左往右输出每一个元素
Status StackTraverse(SqDoubleStack S){
int i;
i=0;
while(i&lt;=S.top1){
    visit(S.data[i++]);
}
i=S.top2;//中间空余部分不输出 
while(i&lt;MAXSIZE){//MAXSIZE实际上是最大的下标加1 
    visit(S.data[i++]);
}
printf(&quot;\n&quot;);
return OK; 
} 

int main(){
int j,e;
SqDoubleStack s;
if(InitStack(&amp;s)==OK){
    for(j=1;j&lt;=5;j++)
        Push(&amp;s,j,1);
    for(j=MAXSIZE;j&gt;=MAXSIZE-2;j--)
        Push(&amp;s,j,2);
}
printf(&quot;栈中的元素依次为：&quot;);
StackTraverse(s);
printf(&quot;当前栈中元素有：%d\n&quot;,StackLength(s));

Pop(&amp;s,&amp;e,2);
printf(&quot;弹出的栈顶元素 e=%d\n&quot;,e);
printf(&quot;栈空否：%d(1:空 0:否)\n&quot;,StackEmpty(s));

for(j=6;j&lt;=MAXSIZE-2;j++)
    Push(&amp;s,j,1);

printf(&quot;栈中的元素依次为：&quot;);
StackTraverse(s);

printf(&quot;栈满否: %d(1:否 0:满)\n&quot;,Push(&amp;s,100,1));

ClearStack(&amp;s);
printf(&quot;清空栈后，栈空否：%d(1:空 0:否)\n&quot;,StackEmpty(s));        
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级学习笔记（二）</title>
    <url>/2019/12/23/PAT%E4%B9%99%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>##续接PAT乙级学习笔记（一）<br>##以下PAT乙级模拟题<br>1.B1053住房空置率。注意变量的命名方式，更加有助于解题和找bug。注意题目中输出一位小数点百分数的方式，（double）强制类型转换。  </p><pre><code>double mayvoid1=(double)mayvoid/n*100;
double isvoid1=(double)isvoid/n*100;
printf(&quot;%.1f%% %.1f%%&quot;,mayvoid1,isvoid1);  </code></pre><a id="more"></a>
<p>使用%%来输出一个%。使用\来输出一个,对于其他的转义字符需要\来输出，如printf(“\n”）将输出一个\n。<br>2.B1051复数乘法。当A或B在-0.005到+0.005之间时候，应该输出0.00而不应该输出-0.00，所以在输出的时候需要有一步判断。<br>3.B1050螺旋矩阵。这道题的思路不是很明确，不知道怎么样输出螺旋矩阵，所以做不出来。柳神给出来的思路很明确，需要借鉴参考学习。<br>4.B1046划拳。比较简单的一道题，5分钟就搞定了，注意书写变量的命名。<br>5.B1026程序运行时间。认真体会四舍五入时加上50的写法。注意当其中一项是0的时候应该输出00所以输出格式应该是%02d。输出控制符%.mf是保障精确到小数点后面几位，不是四舍五入，四舍五入应该用round（double）函数。<br>6.B1018锤子剪子布。题目较简单，注意变量命名的方式，一定要让自己能够看懂。对于每一个人胜利的存储可以参考柳神的方式，用数组，然后找出最大的下标。很巧妙。  </p>
<pre><code>int maxjia = jia[0] &gt;= jia[1] ? 0 : 1;
maxjia = jia[maxjia] &gt;= jia[2] ? maxjia : 2;
int maxyi = yi[0] &gt;= yi[1] ? 0 : 1;
maxyi = yi[maxyi] &gt;= yi[2] ? maxyi : 2;
char str[4] = {&quot;BCJ&quot;};
cout &lt;&lt; str[maxjia] &lt;&lt; &quot; &quot; &lt;&lt; str[maxyi];  </code></pre><p>7.B1016部分A+B。题目较简单，认为书写函数的方式要好于柳神的方法，代码也比较短。  </p>
<p>##以下PAT乙级数学题<br>1.B1056组合数的和。本题每个输入的数，相当于被加了N-1次，所以可以使用柳神的方式<code>sum += temp * 10 * (N - 1) + temp * (N - 1);</code>当然考场上如果想不起来，也可以使用两层for循环来写，也非常简单。<br>2.1049数列的片段和。编程不难，数学思想比较难想到，可以通过画图找规律，每一个数实际上都是被加了（n-i）*（n+1）次，通过在纸上演算可以得到。也可以参考柳神的代码用双指针的思想考虑，每个片段的头指针有i种选择，每个尾指针有n-1-i种选择。<br>3.B1019数字黑洞。这是一道做过的题，注意输入可能不是4位数，计算的过程中可能不是4位数，所以需要两次判断。<code>s.insert(0,4-s.length(),&#39;0&#39;);</code>这种插入的用法必须学会。另外当输入为6174的时候也需要进行循环，所以需要使用do语句，不能使用while语句。<br>##以下是PAT乙级HASH散列问题<br>1.B1083是否存在相等的数。将相减的数直接作为数组的下标记录个数就行，相对较简单。<br>2.B1047编程团体赛。本题注意柳神的scanf的应用，比我的方法简单太多了。<code>scanf(&quot;%d-%d %d&quot;, &amp;t, &amp;num, &amp;score);</code>我是采用读取字符串，然后判断的方法，简直蠢透了。附上我的代码  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt; 
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
using namespace std;
int main(){
int n,sum[1001]={0};
int maxnum,maxscore=0;
string s;
cin&gt;&gt;n;
getchar();
for(int i=0;i&lt;n;i++){
    int com,score=0;
    getline(cin,s);
    for(int j=0;j&lt;s.length();j++){
        if(s[j]==&apos;-&apos;){
            com=stoi(s.substr(0,j));
        }
        if(s[j]==&apos; &apos;){
            score=stoi(s.substr(j+1));
        }    
    }
    sum[com]+=score;
}
for(int i=1;i&lt;=1000;i++){
    if(sum[i]&gt;maxscore){ 
        maxscore=sum[i];
        maxnum=i;
    }
}
cout&lt;&lt;maxnum&lt;&lt;&quot; &quot;&lt;&lt;maxscore;
return 0;
}  </code></pre><p>附上柳神的代码：  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, t, num, score;
 cin &gt;&gt; n;
 int team[1001] = {0};
 for (int i = 1; i &lt;= n; i++) {
 scanf(&quot;%d-%d %d&quot;, &amp;t, &amp;num, &amp;score);
 team[t] += score;
 }
 int max = 0;
 for (int i = 0; i &lt; 1001; i++) {
 if (team[max] &lt; team[i])
 max = i;
 }
 cout &lt;&lt; max &lt;&lt; &quot; &quot; &lt;&lt; team[max];
 return 0;
}  </code></pre><p>3.B1043输出PATest。我的思路是遍历每一个字符，然后如果字符是P就把他放在字符数组的第1个位置，对于下一个P就把它放在第七个位置，但是代码能力太弱，写出来的漏洞百出。以下附上柳神的代码以供学习：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt; 
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
using namespace std;
int main(){
int map[128]={0},c;\\一共128个ascii码。
while((c=cin.get())!=EOF) map[c]++;
while (map[&apos;P&apos;] &gt; 0 || map[&apos;A&apos;] &gt; 0 || map[&apos;T&apos;] &gt; 0 || map[&apos;e&apos;] &gt; 0 ||map[&apos;s&apos;] &gt; 0 || map[&apos;t&apos;] &gt; 0) {
    if (map[&apos;P&apos;]-- &gt; 0) cout &lt;&lt; &apos;P&apos;;
    if (map[&apos;A&apos;]-- &gt; 0) cout &lt;&lt; &apos;A&apos;;
    if (map[&apos;T&apos;]-- &gt; 0) cout &lt;&lt; &apos;T&apos;;
    if (map[&apos;e&apos;]-- &gt; 0) cout &lt;&lt; &apos;e&apos;;
    if (map[&apos;s&apos;]-- &gt; 0) cout &lt;&lt; &apos;s&apos;;
    if (map[&apos;t&apos;]-- &gt; 0) cout &lt;&lt; &apos;t&apos;;
 }
 return 0;
}  </code></pre><p>4.B1042字符统计。所有变量如果不直接输入都要初始化，这道题如果不初始化t，就会导致测试点2不通过。对于单个字符的hash散列可以使用它的ascii码作为键值。当要求有并列的时候从最小的输出时候，可以从遍历字母的最小的ascii开始。<br>5.B1039到底买不买。每一个珠子个数都存成a[s[i]-‘0’]的形式，a[]里面对应的不一定是这个字符的ascii码，不过不会影响最后的结果，不过像下面这样也是可以的s[i]默认选取其ascii码。柳神的代码采用了两个for循环，不易想到。  </p>
<pre><code>string s1,s2;
cin&gt;&gt;s1&gt;&gt;s2;
for(int i=0;i&lt;s2.length();i++){
    b[s2[i]]++;
}  </code></pre><p>6.B1038统计同成绩的学生的个数。相对简单，柳神的代码中使用了vector容器，我是用了数组保存成绩，注意数组的范围是a[101]。<br>7.B1033旧键盘打印。题目较难，可以参考柳神的代码，尤其注意string：：npos的用法，《算法笔记》p207有详细解释：  </p>
<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cctype&gt;
#include &lt;map&gt;
using namespace std;
int main(){
string bad,should;
getline(cin,bad);
getline(cin,should);
for(int i=0;i&lt;should.length();i++){
    if(bad.find(toupper(should[i]))!=string::npos) continue;
    if(isupper(should[i])&amp;&amp;bad.find(&apos;+&apos;)!=string::npos) continue;
    cout&lt;&lt;should[i];
} 
return 0;
}  </code></pre><p>8.B1029旧键盘。学会了柳神的find函数，对于判断字母还是大小写处理的还不是很好。  </p>
<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cctype&gt;
#include &lt;map&gt;
using namespace std;
int main(){
string s1,s2;
cin&gt;&gt;s1&gt;&gt;s2; 
int a[128]={0};
for(int i=0;i&lt;s1.length();i++){
    if(s2.find(s1[i])==string::npos&amp;&amp;a[s1[i]]==0){
        if(!isalpha(s1[i])){
            a[s1[i]]++;
            cout&lt;&lt;s1[i];
        }else{
            if(islower(s1[i])){
                a[s1[i]-32]++;
                a[s1[i]]++;
                s1[i]=toupper(s1[i]);
                cout&lt;&lt;s1[i];
            }
            else{
                a[s1[i]+32]++;
                a[s1[i]]++;
                cout&lt;&lt;s1[i];    
            }
        }
    } 
} 
return 0;
}    </code></pre><p>柳神的代码采用字符串相加的方式,真是妙！  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cctype&gt;
using namespace std;
int main() {
    string s1, s2, ans;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for (int i = 0; i &lt; s1.length(); i++)
    if (s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) ==string::npos)
    ans += toupper(s1[i]);
    cout &lt;&lt; ans;
 return 0;
}  </code></pre><p>##以下是PAT乙级STL-map题：<br>1.B1090危险品装箱。这道题比较难，参考了柳神的代码：</p>
<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
int n,k,t1,t2;
map&lt;int,vector&lt;int&gt; &gt; m;//每个数关联的数不是确定个，所以使用vector 
scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
for(int i=0;i&lt;n;i++){
    scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2);
    m[t1].push_back(t2);
    m[t2].push_back(t1);
}
while(k--){
    int cnt,flag=0,a[100000]={0};
    scanf(&quot;%d&quot;,&amp;cnt);
    vector&lt;int&gt; v(cnt);
    for(int i=0;i&lt;cnt;i++){
        scanf(&quot;%d&quot;,&amp;v[i]);
        a[v[i]]=1;//将每一个数都设置为1，散列 
    }
    for(int i=0;i&lt;v.size();i++)//从输入的第一个数开始遍历 
        for(int j=0;j&lt;m[v[i]].size();j++)//从每个数关联的数开始遍历 
        if(a[m[v[i]][j]]==1) flag=1;
        //m[v[i][j]]表示关联的第j个数，a[]表示关联的数存在 
    printf(&quot;%s\n&quot;,flag ? &quot;No&quot; : &quot;Yes&quot;); 
}
return 0;
}  </code></pre><p>2.B1085PAT单位排行。题目不会做，参考了柳神的代码。注意写代码的时候的代码风格，变量和运算符之间需要加空格，结束符，逗号等要靠在前面的变量。scanf（“%lf”，&amp;a）中间是字母l不是数字1.      </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node{
    string school;
int tws,ns;
};
bool cmp(node a,node b){
if(a.tws!=b.tws)
    return a.tws&gt;b.tws;
else if(a.ns!=b.ns)
    return a.ns&lt;b.ns;
else
    return a.school&lt;b.school;
}
int main() {
int n;
scanf(&quot;%d&quot;, &amp;n);
unordered_map&lt;string, int&gt; cnt;
unordered_map&lt;string, double&gt; sum;
for(int i = 0;i &lt; n; i++){
    string id,school;
    cin&gt;&gt;id;
    double score;
    scanf(&quot;%lf&quot;,&amp;score);
    cin&gt;&gt;school;
    for(int j=0;j&lt;school.length();j++)
        school[j]=tolower(school[j]);
    if(id[0]==&apos;B&apos;)
        score=score/1.5;
    else if(id[0]==&apos;T&apos;)
        score=score*1.5;
    sum[school]+=score;
    cnt[school]++;
} 
//下面是本题的重点
vector&lt;node&gt; ans;
for(auto it=cnt.begin();it!=cnt.end();it++)
    ans.push_back(node{it-&gt;first,(int)sum[it-&gt;first],cnt[it-&gt;first]});
sort(ans.begin(),ans.end(),cmp);
int rank=0,pres=-1;
printf(&quot;%d\n&quot;,(int)ans.size());
for(int i=0;i&lt;ans.size();i++){
    if(pres!=ans[i].tws) rank=i+1;
    pres=ans[i].tws;
    printf(&quot;%d &quot;,rank);
    cout&lt;&lt;ans[i].school;
    printf(&quot; %d %d\n&quot;,ans[i].tws,ans[i].ns);
} 
return 0;
}  </code></pre><p>3.B1080MOOC期中成绩。这道题和B1085很像，都使用了结构体，自己书写sort的cmp函数，我没做出来，参考的柳神的代码  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
    string name;
    int gp, gm, gf, g;
};
bool cmp(node a, node b){
    return a.g != b.g ? a.g &gt; b.g : a.name &lt; b.name;
}
map&lt;string, int&gt; idx;
int main(){
int p, m, n, score, cnt = 1;
scanf(&quot;%d %d %d&quot;,&amp;p, &amp;m, &amp;n);
vector&lt;node&gt; v, ans;
string s;
for(int i=0;i&lt;p;i++){
    cin &gt;&gt; s &gt;&gt; score;
    if(score&gt;=200) {
        v.push_back(node{s, score, -1, -1, 0});
        idx[s] = cnt++;//起到标记的作用 
    }        
}
for(int i=0; i&lt;m; i++){
    cin &gt;&gt; s &gt;&gt; score;
    if(idx[s] != 0) v[idx[s] - 1].gm = score;
}
for(int i=0; i&lt;n; i++){
    cin &gt;&gt; s &gt;&gt; score;
    if(idx[s]!= 0){
        int temp = idx[s] - 1;
        v[temp].gf = v[temp].g = score;
        if(v[temp].gm &gt; v[temp].gf)
            v[temp].g = int(v[temp].gm*0.4 + v[temp].gf*0.6 + 0.5);
    } 
}
for(int i = 0; i &lt; v.size(); i++)
    if(v[i].g &gt;= 60) ans.push_back(v[i]);
sort(ans.begin(), ans.end(), cmp);
for(int i = 0; i &lt; ans.size();i++)
    printf(&quot;%s %d %d %d %d\n&quot;,ans[i].name.c_str(), ans[i].gp, ans[i].gm, ans[i].gf, ans[i].g);    
return 0;
}</code></pre><p>注意输出时，因为名字使用的%s格式，所以输出的时候需要把.name的string格式变为.name.c_str格式，这一点需要注意。<br>4.B1069微博转发抽奖。本道题自己做出来了，但是思维逻辑有点混乱，参考了柳神的代码。用来做标记的flag可以设置成bool类型false，true。<br>5.B1063火星数字。参考了柳神的代码，柳神的代码书写真的很规范！  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
string a[13] = {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string b[13] = {&quot;####&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
string s;
int len;
void func1(int t) {
    if (t / 13) cout &lt;&lt; b[t / 13];
    if ((t / 13) &amp;&amp; (t % 13)) cout &lt;&lt; &quot; &quot;;
    if (t % 13 || t == 0) cout &lt;&lt; a[t % 13];
}
void func2() {
    int t1 = 0, t2 = 0;
    string s1 = s.substr(0, 3), s2;
    if (len &gt; 4) s2 = s.substr(4, 3);
    for (int j = 1; j &lt;= 12; j++) {
        if (s1 == a[j] || s2 == a[j]) t2 = j;
        if (s1 == b[j]) t1 = j;
}
cout &lt;&lt; t1 * 13 + t2;
}
int main() {
int n;
cin &gt;&gt; n;
getchar();
for (int i = 0; i &lt; n; i++) {
    getline(cin, s);
    len = s.length();
    if (s[0] &gt;= &apos;0&apos; &amp;&amp; s[0] &lt;= &apos;9&apos;)
        func1(stoi(s));
    else
        func2();
    cout &lt;&lt; endl;
}
return 0;
}    </code></pre><p>注意以下的代码风格的规范</p>
<pre><code>void fun1(int x, int y, int z);//良好 
void fun1 (int x,int y,int z); //不良好 

if (year &gt;= 200)    //良好 
if(year&gt;=200)       //不良好 
if ((a&gt;=b) &amp;&amp; (a&lt;=d)) //良好 
if(a&gt;=b&amp;&amp;a&lt;=d)       //不良好 

for (i=0; i&lt;10; i++)       //良好风格 
for(i=0;i&lt;10;i++)         //不良好风格 
for (i = 0; i &lt; 10; i++) //过多的空格 

x = a &lt; b ? a : b;  //良好
x=a&lt;b?a:b;          //不良好

int *x=&amp;b;   //良好
int * x=&amp; b; //不良好</code></pre>]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级学习笔记（一）</title>
    <url>/2019/12/23/PAT%E4%B9%99%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>##开一篇文章记录一下学习PAT乙级过程中遇到的问题。</p>
<p>1.string中截取字符串函数s.substr(2,3),表示从s的下标为2的字符开始连续截取3个字符，其中2和3不能为变量<br>2.B1003 我要通过！map&lt;char,int&gt; mp,当使用mp[‘T’]访问时，返回的是字符T的个数；mp.size()返回的是映射的对数；<br>3.B1004 成绩排名。当输入中有空格的字符串时，可以直接使用cin&gt;&gt;name&gt;&gt;sum来输入，中间的间隔就是空格。输出空格时cout&lt;&lt;” “,双引号之间一定有空格。<a id="more"></a><br>4.B1005 继续3n+1猜想。vector<int> v是两个变长数值，做题时发生了段错误，应该改为vector<int> v[k]表示其中一个是固定长度的。认真体会最后的关于用flag标记来输出中间空格的方法。<br>5.B1006换个格式输出整数。思维不要僵化，用数组存储各个位的数字，用取余%和整除/。<br>6.B1007素数对猜想。记住isprime函数的书写方式  </int></int></p>
<pre><code>bool isprime(int a){
for(int i=2;i*i&lt;=a;i++)
    if(a%i==0) return false;
return true;
}  </code></pre><p>7.B1008数组元素循环右移。使用vector时必须要添加相应的头文件；vector<int> v(N)注意是小括号，当使用[]时表示vector数组  </int></p>
<pre><code>vector&lt;int&gt; a ;      //声明一个int型向量a
vector&lt;int&gt; a(10) ;   //声明一个初始大小为10的向量
vector&lt;int&gt; a(10, 1) ;    //声明一个初始大小为10且初始值都为1的向量
vector&lt;int&gt; b(a) ;       //声明并用向量a初始化向量b
vector&lt;int&gt; b(a.begin(), a.begin()+3) ;//将a向量中从第0个到第2个(共3个)作为向量b的初始值  </code></pre><p>reverse的用法，注意<code>reverse(a,a+4)</code>表示翻转a[0]~a[3]；<br>8.B1010一元多项式求导。认真审题，输出中的0是1-1得0；可以用<code>while(cin&gt;&gt;a&gt;&gt;b)</code>来一直输入；同B1005体会用标记flag来输出空格的方法。<br>9.B1011A+B大于C。读题读3遍，看好细节；大整数运算时必须使用scanf和printf来输入输出；注意各个类型的取值范围  </p>
<pre><code>char -128 ~ +127 (1 Byte)
short -32767 ~ + 32768 (2 Bytes)
unsigned short 0 ~ 65536 (2 Bytes)
int -2147483648 ~ +2147483647 (4 Bytes) 2的31次幂
unsigned int 0 ~ 4294967295 (4 Bytes)
long == int
long long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)
double 1.7 * 10^308 (8 Bytes)
unsigned int 0～4294967295
long long的最大值：9223372036854775807
long long的最小值：-9223372036854775808
unsigned long long的最大值：184467440737095516  </code></pre><p>10.B1012数字分类。用scanf进行输入时，必须使用&amp;，否则会出现段错误，避免段错误有，大数组必须定义在全局变量，数组开小了，sort函数排序出问题。当n1-n2+n3-n4…时可以在每一层循环中加入符号变量s=s*（-1），使用头文件<cmath>中的pow（double n1，double n2）中注意double类型。当输出空格时可以循环printf（” “）,也可以直接输出printf，也可以直接printf(“N “);不存在和等于0不是相等的，所以A2的测试点8一直通不过，这道题简直太精辟了；<br>11.B1013数素数。按照每行10个的输出方式是用循环，注意前后顺序，判断和打印不能颠倒。代码背下来，：</cmath></p>
<pre><code>cnt=0;
for(int i=0;i&lt;v.size();i++){
    cnt++;
    if(cnt%10!=1) printf(&quot; &quot;);
    printf(&quot;%d&quot;,v[i]);
    if(cnt%10==0) printf(&quot;\n&quot;);
}  </code></pre><p>写判断是否为素数的bool函数，要注意括号的位置：  </p>
<pre><code>bool isprime(int a){
for(int i=2;i*i&lt;=a;i++)
    if (a%i==0) return false;
    return true;
}  </code></pre><p>12.B1014福尔摩斯的约会。星期隐含着要A~G。输出的星期要是字符串，时间要是整型。时间注意前面要补零。找到相同的字符串后要跳出。判断分钟的时候用for条件语句时可以使用中间两个条件，当使用if判断条件时，必须在一个if里面全包括如下，如果去掉<code>((s1[j]&gt;=&#39;A&#39;&amp;&amp;s1[j]&lt;=&#39;N&#39;)||isdigit(s1[j]))</code>  就会导致测试点1和2错误。</p>
<pre><code>for(int j=k+1;j&lt;s1.size()&amp;&amp;j&lt;s2.size();j++){
        if(s1[j]==s2[j]&amp;&amp;((s1[j]&gt;=&apos;A&apos;&amp;&amp;s1[j]&lt;=&apos;N&apos;)||isdigit(s1[j]))){
            if(isdigit(s1[j])) printf(&quot;%02d:&quot;,s1[j]-&apos;0&apos;);
            if(s1[j]&gt;=&apos;A&apos;&amp;&amp;s1[j]&lt;=&apos;N&apos;) printf(&quot;%d:&quot;,s1[j]-&apos;A&apos;+10);
            break;
        }
    }。  </code></pre><p>ctype中相关的函数（都是判断一个字符，不能判断字符串）以下结果如果是，就返回设定值，如果不是就返回原来的值，所以可以直接用，不用判断是否为大写字母等，如果是就tolower例子见B1029.    </p>
<pre><code>isalnum        是否为字母数字
isalpha        是否为字母
islower        是否为小写字母
isupper        是否为大写字母
isdigit        是否为数字
isxdigit    是否为16进制数字
iscntrl        是否为控制字符
isgraph        是否为图形字符（例如，空格、控制字符都不是）
isspace        是否为空格字符（包括制表符、回车符、换行符等）
isblank        是否为空白字符(C99/C++11新增)（包括水平制表符）
isprint        是否为可打印字符
ispunct        是否为标点
tolower        转换为小写
toupper        转换为大写</code></pre><p>这道题是一道文字游戏题，一定要认真审题后再下笔。  </p>
<p>##以下是乙级字符串处理的题：<br>1.B1021个位数统计。比较简单，vector<int> a[10]表示建立一个vector数组，a[0]~a[9]每一个都是一个vector容器，vector常见用法如下：    </int></p>
<pre><code>（1）a.assign(b.begin(), b.begin()+3); //b为向量，将b的0~2个元素构成的向量赋给a
（2）a.assign(4,2); //是a只含4个元素，且每个元素为2
（3）a.back(); //返回a的最后一个元素
（4）a.front(); //返回a的第一个元素
（5）a[i]; //返回a的第i个元素，当且仅当a[i]存在2013-12-07
（6）a.clear(); //清空a中的元素
（7）a.empty(); //判断a是否为空，空则返回ture,不空则返回false
（8）a.pop_back(); //删除a向量的最后一个元素
（9）a.erase(a.begin()+1,a.begin()+3); //删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）
（10）a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5
（11）a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4
（12）a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5
（13）a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8
（14）a.size(); //返回a中元素的个数；
（15）a.capacity(); //返回a在内存中总共可以容纳的元素个数
（16）a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
（17）a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
（18）a.reserve(100); //将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） 
（19）a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换
（20）a==b; //b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;  </code></pre><p>2.B1024科学技术法。寻找字符串中某一个字符的位置可以用<code>int i=0;while(s[i]!=&#39;E&#39;) i++;</code>。截取字符串和截取字符串转换为数字可以使用<code>string t=s.substr(1,i-1);//这是E前面的字符串 //int n=stoi(s.substr(i+1));//从i+1开始一直截取到最后//</code>.注意体会一个for循环中有两对条件的方法。<br>3.B1031查验身份证。当出现有判断时，先考虑是否采用函数，方程更简单。学会string每一位校验的时候，出现特殊情况怎么处理，将它剔除来单独处理。<code>int tmp=(s[17]==&#39;X&#39;) ? 10 : (s[17]-&#39;0&#39;);return b[num%11]==tmp;</code>这个返回写的太棒了。cin输入结束是以空格结束的。用flag来标记是否已经输出的方法继续学习。<br>4.B1048数字加密。A的长度大于B时，加不加0需要商讨。学会用字符串反转，<code>reverse(a.begin(),a.end());</code>a为字符串。学会使用append用法。<code>b.append(lena-lenb,&#39;0&#39;);</code>表示在字符b的结尾添加lena-lena长度的字符‘0’。使用append()添加文本常用方法:直接添加另一个完整的字符串:如str1.appen(str2);<br>添加另一个字符串的某一段子串:如str1.append(str2, 11, 7);<br>添加几个相同的字符:如str1.append(5, ‘.’);。用字符串来存储加密之后的结果<code>c+=str[(a[i]-&#39;0&#39;+b[i]-&#39;0&#39;)%13];</code>。定义字符数组用<code>char str[14]={&quot;0123456789JQK&quot;};</code>访问时可以直接使用str[n]来访问。<br>5.B1052卖个萌。break只能跳出一层循环，只能用于do~while,for,while语句，不能用于if语句，continue语句表示本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环，continue语句并没有使整个循环终止。<code>vector&lt;vector&lt;string&gt; &gt;v</code>。相当于二维可变长度数组。\表示转义字符，当想输出时必须再加上\即\。一行内有空格时必须使用<code>string s;getline(cin,s);</code>来读入一行。注意变量的定义位置，当把<code>vector&lt;string&gt; row;</code>定义在三层循环外面的时候会出现答案错误。中间读取字符的时候多用while语句，类似于一个双指针的操作，十分精彩。贴上大神的代码：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
vector&lt;vector&lt;string&gt; &gt; v;
for(int i=0;i&lt;3;i++){
    string s;
    getline(cin,s);
    int j=0,k=0;
    vector&lt;string&gt; row;
    while(j&lt;s.length()){
        if(s[j]==&apos;[&apos;){
            while(k++&lt;s.length()){
                if(s[k]==&apos;]&apos;){
                    row.push_back(s.substr(j+1,k-j-1));
                    break;
                }                    
            }
        }
        j++;
    }
    v.push_back(row);    
}
int n,a,b,c,d,e;
cin&gt;&gt;n;
for(int i=0;i&lt;n;i++){
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;
    if(a&gt;v[0].size()||b&gt;v[1].size()||c&gt;v[2].size()||d&gt;v[1].size()||e&gt;v[0].size()||a&lt;1||b&lt;1||c&lt;1||d&lt;1||e&lt;1){
        cout&lt;&lt;&quot;Are you kidding me? @\\/@&quot;&lt;&lt;endl;
        continue;
    }    
    cout&lt;&lt;v[0][a-1]&lt;&lt;&quot;(&quot;&lt;&lt;v[1][b-1]&lt;&lt;v[2][c-1]&lt;&lt;v[1][d-1]&lt;&lt;&quot;)&quot;&lt;&lt;v[0][e-1]&lt;&lt;endl;        
}
return 0;    
}    </code></pre><p>6.B1054求平均值。当输入有不同字符时，可以采用sscanf和sprintf来实现不同格式的输入输出<code>scanf(&quot;%s&quot;, a);sscanf(a,&quot;%lf&quot;,&amp;temp);sprintf(b,&quot;%.2f&quot;,temp);</code>其中a和b为字符数组。scanf结束的几种方式，空格或跳格，超过指定宽度，当非法输入。判断是否是非法字符的方式如下，用读入两位小数的字符数组长度和原来的字符数组长度长度来计算：方法很巧妙。    </p>
<pre><code>for(int j=0;j&lt;strlen(a);j++){
        if(a[j]!=b[j]) flag=1;
        if(flag||tmp&lt;-1000||tmp&gt;1000){
            printf(&quot;ERROR: %s is not a legal number\n&quot;,a);
            continue;
        }
        else{
            sum+=tmp;
            cnt++;
        }
    }  </code></pre><p>7.B1067试密码。PAToj中输入和输出可以一起输出，也可以单次输出。用getchar（）来吸收后面的换行”\n”。getline（cin，s)可以一次输入一整行。做好题目的分析，最后先打好流程图。<br>8.B1081检查密码。非空字符串也可以是空格，所以不能用cin来读入，需要使用<code>getline(cin,s)</code>来读入一行。第一行读入之后要求将最后回车键吸收掉<code>getchar()</code>.对于PAT考试，“对于有多组测试数据的输入，可以全部读入之后再输出，也可以处理一组测试数据就输出一组”，详见PAT运行说明。<br>9.B1084外观数列。当定义二维vector数组时，vector&lt;vector<int> &gt;v(45)后面尽量写上一个维的大小，否则容易容器下标越界。本题是采用双指针的方法，认真体会指针回溯的过程：  </int></p>
<pre><code>for(int i=0;i&lt;s.length();**i=j**){
        for(j=i;j&lt;s.length()&amp;&amp;s[j]==s[i];j++);
        t+=s[i]+to_string(j-i);    
    }  </code></pre><p>10.B1086就不告诉你。输出要是数字，使用stoi（）函数来实现。将数字反转的时候采用reverse（s.begin(),s.end())来实现。<br>11.B1058选择题。注意变量的命名方式一定要规范，绝对不能出现拼音。用vector&lt;set<char> &gt;rigtht(m)来存储每道题的正确答案可以保证一定是按照字母顺序输入的，同时使用st<char>来存储学生的答案。注意本题当中所使用的scanf（“ %c”，&amp;c）的用法，当以%c的形式来读入时是可以读入空格的。  </char></char></p>
<p>##以下是PAT乙级的逻辑题<br>1.B1084三人行。<code>double c=2*1.0/5，cout&lt;&lt;c;</code>等于0.4。<code>double c=2/5，cout&lt;&lt;c;</code>等于0。<code>double(2/5)</code>表示先进行除法，再进行强制类型转换。注意输出格式是一行内还是多行。本题的输出可以用一个函数：<br>    void print(double t) {<br>    if (m == t) printf(“ Ping”);<br>    else if (m &lt; t) printf(“ Cong”);<br>    else printf(“ Gai”);<br>    }<br>  注意abs(a-b)的使用，返回的是int类型，fabs返回的是double类型。一个两位数的倒着输出可以用<code>= i % 10 * 10 + i / 10;</code>同样的三位数也适用。<br>2.B1082射击比赛。可以采用<algorithm>下的MAX()来取最大值。本题是一道先假设最大和最小之后依次替换的典型题目，注意当n=0时，即最大和最小都是一个人的时候。<br>3.B1079延迟的回文数。大整数计算的写法：  </algorithm></p>
<pre><code>string add(string s1,string s2){
string s=s1;
int carry=0;
for(int i=s1.length()-1;i&gt;=0;i--){
    s[i]=(s1[i]-&apos;0&apos;+s2[i]-&apos;0&apos;+carry)%10+&apos;0&apos;;//字符串先变成数字进行运算再加上&apos;0&apos;变成字符。 
    carry=(s1[i]-&apos;0&apos;+s2[i]-&apos;0&apos;+carry)/10;
}
if(carry&gt;0) s=&apos;1&apos;+s;
return s;
}  </code></pre><p>注意reverse是一个函数的过程，不能够赋值，string s=reverse(a.begin(),a.end())这样的写法会出现问题；判断是否是回文数字的时候采用的是函数内写reverse()的方法。主函数当中如果出现return 0；就表示直接退出主函数，程序结束运行。<br>4.B1078字符串的压缩与解压。当压缩的时候也可以不采用双指针的方式，也可以采用单指针加上while循环的形式。注意解压的时候数字不一定是一位数，也可能是多位数，认真体会下面的统计位数的函数。  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
using namespace std;
void c(string s){
int j=0;
for(int i=0;i&lt;s.length();i++){
    int cnt=0;
    while(s[i]==s[i+1])
        i++,cnt++; 
    if(cnt!=0) cout&lt;&lt;cnt+1;
    cout&lt;&lt;s[i];  
}    
}
void d(string s){
for(int i=0;i&lt;s.length();i++){
    int sum=0;
    while(isdigit(s[i]))
        sum=sum*10+s[i++]-&apos;0&apos;;
    for(int j=0;j&lt;sum;j++)
        cout&lt;&lt;s[i];
    if(sum==0)
        cout&lt;&lt;s[i];
}
}
int main(){
string s,s0;
cin&gt;&gt;s0;
getchar();
getline(cin,s);
if(s0==&quot;C&quot;) c(s);
if(s0==&quot;D&quot;) d(s); 
return 0;    
}</code></pre><p>5.B1074宇宙无敌加法器。当从字符串最后一项是是s[s.length()-1]。注意“==”的书写。自定义函数当中变量的改变不会影响主函数中变量的改变。注意本道题中s（进制数字符）需要初始化，算法中直接赋值了。加法器定义的array必须定义在循环的外侧。加法器每一次只能够进1位。如何使用flag只标记一次，本题给出了if的方法。  </p>
<pre><code>for(int i = 0; i &lt; ans.size(); i++) {
if (ans[i] != &apos;0&apos; || flag == 1) {
flag = 1;
cout &lt;&lt; ans[i];
}
}</code></pre><p>当两个字符串需要补同样长的时候，除了使用，reverse（）反转再使用append（）在字符后加0之外，也可以采取本题的方式，很巧妙。  </p>
<pre><code>string ss1(s.length() - s1.length(), &apos;0&apos;);
 s1 = ss1 + s1;
string ss2(s.length() - s2.length(), &apos;0&apos;);
s2 = ss2 + s2;  </code></pre><p>6.B1060爱丁顿数。本题的大数组定义在了函数内部也没有超时，但是时间明显增加了很多，为了保险起见，大数组还是要开全局。数组的下标可以从1开始，不一定要从0开始，注意使用的时候也是从下标1开始的如sort。当书写sort的比较函数的时候，为了产生冲突，把比较函数定义为cmp1。本题有一个测试点没做出来，因为题意理解不明白…..<br>7.B1059C语言竞赛。注意模块化编程的思想，分步骤完成每一个功能。当出现要更改的时候，一定要把所有的地方都改到，本题就是把cout输出改为printf输出的时候有一个地方没改到导致测试点2通过不了。注意体会柳神代码中，使用set来标记是否输出的方法，set可以自动去掉查找的过程中重复的id插入：  </p>
<pre><code>if(ss.find(id) == ss.end()) //表示没有找到id值就插入
ss.insert(id);
} else {
printf(&quot;Checked\n&quot;);
continue;
}  </code></pre><p>8.B1063输出谱半径。注意printf函数中%md,%0md,%.mf这三种用法。<br>9.B1040有多少个PAT.本题如果暴力求解（就是使用三层for循环）会导致运算结果超时。本题的核心是先找A，找到A 就把结果更新，对于每一个A，它的左侧的P个数和右侧的T个数乘积就是这个A对应的PAT，所有结果相加就得到最后结果。这里有一个技巧是先遍历一遍字符串，求出T的个数，然后，每次判断如果为T 就把T个数减1.注意更新结果的时候每一次都对1000000007取余，结果更小。 </p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>delay需要重复输入github密码的解决</title>
    <url>/2019/11/24/delay%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5github%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近开始更新博客时，发现每一次hexo d都需要重新输入密码，对照参考网上的解决办法，应该是本地库与远程库的连接为https（github支持SSH连接和https连接，免密码连接应该是<strong>SSH连接</strong>）：  </p>
<h4 id="1查看配置SSH-秘钥是否有效"><a href="#1查看配置SSH-秘钥是否有效" class="headerlink" title="1查看配置SSH 秘钥是否有效"></a>1查看配置SSH 秘钥是否有效</h4><p>先登录你的github，在setting目录下点击是否有公钥如下图，如果没有，需要重新生成新的公钥进行部署  <a id="more"></a></p>
<p><img src="/2019/11/24/delay%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5github%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3/ssh1%E6%88%AA%E5%9B%BE.png" alt></p>
<h4 id="2查看你的github博客仓库连接方式"><a href="#2查看你的github博客仓库连接方式" class="headerlink" title="2查看你的github博客仓库连接方式"></a>2查看你的github博客仓库连接方式</h4><p>在博客仓库的download下查看是否为SSH连接方式，如下图应该显示clone with ssh  </p>
<p><img src="/2019/11/24/delay%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5github%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3/ssh%E6%88%AA%E5%9B%BE.png" alt></p>
<h4 id="3查看hexo框架下的配置文件"><a href="#3查看hexo框架下的配置文件" class="headerlink" title="3查看hexo框架下的配置文件"></a>3查看hexo框架下的配置文件</h4><p>在hexo框架下查看配置文件config.yml，你的url应该从https改为ssh模式  </p>
<p><code>repo: www.github.com/Araik-77/Araik-77.github.io.git</code><br>应该改为下面这个<br><code>repo: git@github.com/Araik-77/Araik-77.github.io.git</code>  </p>
<p>至此，问题已经解决</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title>MyFirstArticle</title>
    <url>/2019/11/11/MyFirstArticle/</url>
    <content><![CDATA[<p>这是我的第一篇博客，主要记录一下自己喜悦的心情。在2019年双11的凌晨3点钟，我终于折腾出自己的第一个博客。新的开始，加油！</p>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
