<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT甲级学习笔记（二）</title>
    <url>/2020/05/07/PAT%E7%94%B2%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C)/</url>
    <content><![CDATA[<p>##续接上一篇PAT甲级DFS相关题目<br>1.1030 Travel Plan (30分)<a id="more"></a>   </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF = 99999999;
const int MAXN = 510;
bool vis[MAXN] = {false};
vector&lt;int&gt; pre[MAXN];
vector&lt;int&gt; path, tempPath;
int d[MAXN], minCost = INF;
//定义图
int G[MAXN][MAXN], C[MAXN][MAXN]; 
int n, m, st, ed, c1, c2, dist, cost;
void Dijkstra(int s){
    fill(d, d + MAXN, INF);//要初始化距离 
    d[s] = 0;//千万别忘了定义节点到自己的距离 
    for(int i = 0; i &lt; n; i++){
        int u = -1, MIN = INF;
        for(int j = 0; j &lt; n; j++){
            if(vis[j] == false &amp;&amp; d[j] &lt; MIN){
                u = j;
                MIN = d[j];
            }
        }
        if(u == -1) return;
        vis[u] = true;
        for(int v = 0; v &lt; n; v++){
            if(vis[v] == false &amp;&amp; G[u][v] != INF){
                if(d[v] &gt; G[u][v] + d[u]){
                    d[v] = G[u][v] + d[u];
                    pre[v].clear();
                    pre[v].push_back(u);
                }else if(d[v] == G[u][v] + d[u]){
//                    d[v] = G[u][v] + d[u];不用更新，距离相等更新啥 
                    pre[v].push_back(u);
                }
            }
        }
    }
} 
void DFS(int v){
    if(v == st){
        tempPath.push_back(v);
        int tempCost = 0;
        for(int i = tempPath.size() - 1; i &gt; 0; i--){
            int id = tempPath[i], idNext = tempPath[i-1];
            tempCost += C[id][idNext];
        }
        if(tempCost &lt; minCost){
            minCost = tempCost;
            path = tempPath;
        }
        tempPath.pop_back();
        return;
    }
    tempPath.push_back(v);
    for(int i = 0; i &lt; pre[v].size(); i++){
        DFS(pre[v][i]);
    }
    tempPath.pop_back();
}
int main(){
    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed);
    fill(G[0], G[0] + MAXN * MAXN, INF);//初始化图和花费 
    fill(C[0], C[0] + MAXN * MAXN, INF);
    for(int i = 0; i &lt; m; i++){
        scanf(&quot;%d%d%d%d&quot;, &amp;c1, &amp;c2, &amp;dist, &amp;cost);
        G[c1][c2] = G[c2][c1] = dist;
        C[c1][c2] = C[c2][c1] = cost;
    }
    Dijkstra(st);
    DFS(ed);
    for(int i = path.size()-1; i &gt;= 0; i--){
        printf(&quot;%d &quot;, path[i]);
    } 
    printf(&quot;%d %d\n&quot;, d[ed], minCost);
    return 0;
}   </code></pre><p>这是一道很经典的题目，要多看看，固定一下自己的书写方法。这道题需要注意1.一维数组和二维数组的初始化方式要记牢，否则会出现指针错误。2.Dijkstra时注意核心语句if的书写。3.输出路径的时候注意需要倒序输出，不要蒙，pre，tempPath，path不要写乱了。<br>2.1018 Public Bike Management (30分)  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF = 99999999;
const int MAXN = 510;
int G[MAXN][MAXN], d[MAXN], w[MAXN];
bool vis[MAXN] = {false};
vector&lt;int&gt; path, tempPath;
vector&lt;int&gt; pre[MAXN];
int cmax, n, sp, m, at, bt, ct;
int minNeed = INF, minRemain = INF;
void Dijkstra(int s){
    fill(d, d + MAXN, INF);
    d[s] = 0;
    for(int i = 0; i &lt;= n; i++){
        int u = -1, MIN = INF;
        for(int j = 0; j &lt;= n; j++){
            if(vis[j] == false &amp;&amp; d[j] &lt; MIN){
                u = j;
                MIN = d[j];
            }
        }
        if(u == -1) return;
        vis[u] = true;
        for(int v = 0; v &lt;= n; v++){
            if(vis[v] == false &amp;&amp; G[u][v] != INF){
                if(d[v] &gt; d[u] + G[u][v]){
                    d[v] = d[u] + G[u][v];
                    pre[v].clear();
                    pre[v].push_back(u);
                }else if(d[v] == d[u] + G[u][v]){
                    pre[v].push_back(u);
                }
            }
        }
    }
}
void DFS(int u){
    if(u == 0){
        tempPath.push_back(u);
        int need = 0, remain = 0;
        for(int i = tempPath.size() - 1; i &gt;= 0; i--){
            int id = tempPath[i];
            if(w[id] &gt; 0){
                remain += w[id];
            }else{
                if(remain &gt; abs(w[id])){
                    remain -= abs(w[id]);
                }else{
                    need += abs(w[id]) - remain;
                    remain = 0;
                }
            }
//            tempw += w[tempPath[i]];
        }
        if(need &lt; minNeed){
            minNeed = need;
            minRemain = remain;
            path = tempPath;
        }else if(need == minNeed &amp;&amp; remain &lt; minRemain){
            minRemain = remain;
            path = tempPath;
        }
        tempPath.pop_back();
        return;
    }
    tempPath.push_back(u);
    for(int i = 0; i &lt; pre[u].size(); i++){
        DFS(pre[u][i]);
    }
    tempPath.pop_back();
}
int main(){
    scanf(&quot;%d%d%d%d&quot;, &amp;cmax, &amp;n, &amp;sp, &amp;m);
    fill(G[0], G[0] + MAXN*MAXN, INF);
//    fill(w, w + MAXN, INF);
    for(int i = 1; i &lt;= n; i++){
        scanf(&quot;%d&quot;, &amp;w[i]);
        w[i] = w[i] - cmax/2;
    }
//    w[0] = 0;
    for(int i = 0; i &lt; m; i++){
        scanf(&quot;%d%d%d&quot;, &amp;at, &amp;bt, &amp;ct);
        G[at][bt] = G[bt][at] = ct;
    }
    Dijkstra(0);
    DFS(sp);
    printf(&quot;%d &quot;, minNeed);
    for(int i = path.size()-1; i &gt;= 0; i--){
        printf(&quot;%d&quot;,path[i]);
        if(i &gt; 0) printf(&quot;-&gt;&quot;);
    }
    printf(&quot; %d&quot;, minRemain);
    return 0;
}  </code></pre><p>注意固定这种题目的写法都是Dijkstra + DFS,不管是不是最优子结构，都固定成这样的写法，这道题是点权，上一道题是边权，这两道题一定要记下来。<br>3.1087 All Roads Lead to Rome (30分)  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf =  99999999;
const int maxn = 210; 
map &lt;string, int&gt; m1;
map &lt;int, string&gt; m2;
int G[maxn][maxn], d[maxn], weight[maxn];
vector &lt;int&gt; path, temppath, pre[maxn];

bool vis[maxn] = {false}; 
int n, k, st;
int numpath = 0, maxw = 0;
double maxavg = 0;

void dijks(int s){
//    cout &lt;&lt;&quot;*&quot;;
    fill(d, d + maxn, inf);
    d[s] = 0;
    for(int i = 0; i &lt; n; i++){
        int u = -1, min = inf;
        for(int j = 0; j &lt; n; j++){
            if(vis[j] == false &amp;&amp; d[j] &lt; min ){
                u = j;
                min = d[j];
            }
        } 
        if(u == -1) return;
        vis[u] = true;
        for(int v = 0; v &lt; n; v++){
            if(vis[v] == false &amp;&amp; G[u][v] != inf){
                if(d[v] &gt; d[u] + G[u][v]){
                    d[v] = d[u] + G[u][v];
                    pre[v].clear();
                    pre[v].push_back(u);
                }else if(d[v] == d[u] + G[u][v]){
                    pre[v].push_back(u);
                }
            }
        }
    }    
}
void dfs(int v){
    if(v == st){
        temppath.push_back(v);
        numpath++;
        int tempw = 0;
        for(int i = temppath.size() - 2; i &gt;= 0; i--){
            int id = temppath[i];
            tempw += weight[id];
//            cout &lt;&lt; &quot;tempw = &quot; &lt;&lt; tempw &lt;&lt; endl;
        }
        double tempavg = 1.0*tempw/(temppath.size()-1);
        if(tempw &gt; maxw){
//            tempw = maxw;
            maxw = tempw;
            maxavg = tempavg;
            path = temppath;
        }else if(tempw == maxw &amp;&amp; tempavg &gt; maxavg){
            maxavg = tempavg;
            path = temppath;
        }
        temppath.pop_back();
        return;
    }
    temppath.push_back(v);
    for(int i = 0; i &lt; pre[v].size(); i++){
        dfs(pre[v][i]);
    }
    temppath.pop_back();
}
int main(){
    string c1, c2, start;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; start;
    m1[start] = 0;
    m2[0] = start;
    for(int i = 1; i &lt;= n-1; i++){
        cin &gt;&gt; c1 &gt;&gt; weight[i];
        m1[c1] = i;
        m2[i] = c1;
    }
    fill(G[0], G[0] + maxn*maxn, inf);
    for(int i = 0 ; i &lt; k; i++){
        int cost;
        cin &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; cost;
        int city1 = m1[c1], city2 = m1[c2];
        G[city1][city2] = G[city2][city1] = cost; 
    }
    dijks(0);
    int rom = m1[&quot;ROM&quot;];
    dfs(rom);
//    cout &lt;&lt; rom &lt;&lt;&quot;*&quot; &lt;&lt; endl;
    printf(&quot;%d %d %d %d\n&quot;,numpath, d[rom], maxw, (int)maxavg);
    for(int i = path.size() - 1; i &gt;= 0; i--){
        cout &lt;&lt; m2[path[i]];
        if(i &gt; 0) cout &lt;&lt; &quot;-&gt;&quot;;
//        cout &lt;&lt;&quot;%&quot;;
    }   
    return 0;
}  </code></pre><p>4.1146 Topological Order (25分)  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main(){
    int n, m, a, b, k, flag = 0, in[1010];
    vector&lt;int&gt; v[1010]; 
    scanf(&quot;%d %d&quot;,&amp;n, &amp;m);
    for(int i = 0; i &lt; m; i++){
        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
        v[a].push_back(b);
        in[b]++;
    }
    scanf(&quot;%d&quot;, &amp;k);
    for(int i = 0; i &lt; k; i++){
        int judge = 1;
        vector&lt;int&gt; tin(in, in+n+1);
        //用in来初始化tin，起点表示从in[0]开始，一直到in[n],中间是两个指针迭代器
        //只包括左边，不包括右边，所以应该是n+1而不是n 
        for(int j = 0; j &lt; n; j++){
            scanf(&quot;%d&quot;,&amp;a);
            if(tin[a] != 0) judge = 0;
//            for(int it : v[a]) tin[it]--;//遍历v[a]的每一个数,相当于下面的语句 
            for(int l = 0; l &lt; v[a].size(); l++){
                tin[v[a][l]]--;
            } 
        }
        if(judge == 1) continue;
        printf(&quot;%s%d&quot;, flag == 1 ? &quot; &quot; : &quot;&quot;, i);
        flag = 1;
    }
    return 0;
}  </code></pre><p>本题是一道关于拓扑排序的题，要注意如何设置临时的tin容器，并使用in数组来初始化，对于下面的遍历部分可以采用我自己的写法，更方便理解，不容易出错。</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级学习笔记（一）</title>
    <url>/2020/03/02/PAT%E7%94%B2%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80)/</url>
    <content><![CDATA[<p>##以下PAT链表数据结构相关题目<br>1.A1032Sharing。本题要求你写一个程序找出两个链表中第一个相同的结点的位置，先用list存储结点，遍历第一个链表（注意遍历链表的写法）将所有结点标记为true，再遍历第二个链表，当出现第一个true的时候打印此时的结点地址，也就是list的下标，相对简单，注意这道题目中主函数中有两个返回出口  </p><a id="more"></a>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
struct node{
    char data;
    int next;
    bool flag;
} list[100000];
int main(){
    int start1, start2, n;
    scanf(&quot;%d %d %d&quot;, &amp;start1, &amp;start2, &amp;n);

    for(int i = 0; i &lt; n; i++){
        char c;
        int a, b;
        scanf(&quot;%d %c %d&quot;,&amp;a, &amp;c, &amp;b);
        list[a] = {c, b, false};
    }
    for(int i = start1; i != -1; i = list[i].next){
        list[i].flag = true;
    }
    for(int i = start2; i != -1; i = list[i].next){
        if(list[i].flag == true){
            printf(&quot;%05d&quot;,i);
            return 0;
        }
    }
    printf(&quot;-1&quot;);
    return 0;
}   </code></pre><p>2.A10521052 Linked List Sorting。注意链表元素不在结构中的情况一定要考虑进去，这道题没做出来是因为不会链表的赋值操作，注意柳神代码中的<code>list[a] = {a, b, c, false}</code>的写法。本题的第四个测试点考察如果链表元素为0的时候应该输出0 -1，所以一定要考虑进去  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
struct node{
    int address, key, next;
    bool flag;
}list[100005];
bool cmp(node a, node b){
    return !a.flag || !b.flag ? a.flag &gt; b.flag : a.key &lt; b.key;
}
int main(){
    int n, first, a, b, c, sum = 0;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;first);
    for(int i = 0; i &lt; n; i++){
        scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);
        list[a] = {a, b, c, false};
    }
    for(int p = first; p != -1; p = list[p].next ){
        sum++;
        list[p].flag = true;
    }
    sort(list, list + 100000, cmp);
    if(sum == 0) printf(&quot;0 -1&quot;);
    else{
        printf(&quot;%d %05d\n&quot;, sum, list[0].address);
        for(int i = 0; i &lt; sum; i++){
            if(i == 0){
                printf(&quot;%05d %d&quot;, list[i].address, list[i].key);
            }else{
                printf(&quot; %05d\n&quot;, list[i].address);
                printf(&quot;%05d %d&quot;,list[i].address, list[i].key);
            }
        } 
        printf(&quot; -1&quot;);
    }

    return 0;
} </code></pre><p>3.A1097 Deduplication on a Linked List.这道题先输入链表，然后用flag进行标记，已经输出过的地址的flag标记为1，先输出统计没有重复的，然后把重复的赋值给ans，最后再输出。注意题目中的数组大小，避免如果ans数组开小了，会出现段错误  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
struct node {
    int data,next;
}list[100005];

struct node1{
    int address, data;
}ans[100005];

int flag[10005] = {0};
int main(){
    int first, n;
    scanf(&quot;%d %d&quot;, &amp;first, &amp;n);
    for(int i = 0; i &lt; n; i++){
        int temp;
        scanf(&quot;%d&quot;, &amp;temp);
        scanf(&quot;%d %d&quot;,&amp;list[temp].data, &amp;list[temp].next);
    }
    int sgn = 0, sum = 0;
    for(int p = first; p != -1; p = list[p].next){
        if(sgn == 0){
            printf(&quot;%05d %d &quot;, p, list[p].data);
            flag[abs(list[p].data)] = 1;
            sgn = 1; 
        }else{
            if(flag[abs(list[p].data)] == 0){
                printf(&quot;%05d\n&quot;, p);
                printf(&quot;%05d %d &quot;, p, list[p].data);
                flag[abs(list[p].data)] = 1;
            }
            else {
                ans[sum].address = p;
                ans[sum].data = list[p].data;
                sum++;

            }    
        }
    }
    printf(&quot;-1\n&quot;);

    int sgn1 = 0;
    for(int i = 0; i &lt; sum ; i++){
        if(sgn1 == 0){
            printf(&quot;%05d %d&quot;, ans[i].address,ans[i].data);
            sgn1 = 1; 
        }else{
            printf(&quot; %05d\n&quot;, ans[i].address);
            printf(&quot;%05d %d&quot;, ans[i].address, ans[i].data);
        }
    }
    if(sum != 0) printf(&quot; -1&quot;);
    return 0;
}  </code></pre><p>柳神的代码使用定义结构体中，增加一个num标记，不需要删除的结点num等于cnt1，需要删除的结点等于cnt2+max，然后按照num大小进行排序，再输出就会得到最后的结果。真的很巧妙。<br>4.A1074Reversing Linked List。这道题有定义变量的时候，next可能是头文件的关键字，所有如果把next数组定义在main函数外边会出现编译不通过的现象。题目中说的是每k个元素反转一次，认真读题，使用数组的一个好处是可以使用sort函数，更加方便，柳神甲级和乙级的题解不太一样，甲级没有使用sort函数，比较麻烦。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int list[100000], data[100000], ans[100000];
int next0[100000];
int main(){
    int first, n, k;
    int temp;

    scanf(&quot;%d %d %d&quot;, &amp;first, &amp;n, &amp;k);
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; temp;
        cin &gt;&gt; data[temp] &gt;&gt; next0[temp];
    }
    int sum = 0;
    while(first != -1){
        list[sum++] = first;
        first = next0[first];
    }
    for(int i = 0; i &lt; sum; i++) ans[i] = list[i];
    for(int i = 0; i &lt; (sum - sum % k); i += k){//每k个结点一逆转 
        reverse(begin(list) + i, begin(list) + i + k ); 
    } 
    for(int i = 0; i &lt; sum - 1; i++)
        printf(&quot;%05d %d %05d\n&quot;, list[i], data[list[i]], list[i + 1]);
    printf(&quot;%05d %d -1&quot;,list[sum - 1], data[list[sum - 1]]);    
    return 0;
}   </code></pre><p>##以下是PAT甲级dfs题目<br>1.A1013 Battle Over Cities.这道题注意理解dfstrave的部分直接放在了main（）函数当中。这是求连通分量的一个模板解法，要记下来  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int G[1010][1010];
bool visit[1010];
int n;
void dfs(int u){
    visit[u] = true;
    for(int i = 1; i &lt;= n; i++){
        if(visit[i] == false &amp;&amp; G[u][i] == 1)//结点没有被访问，并且结点到下一个结点有路径 
            dfs(i);
    } 
}
int main(){
    int m, k, a, b;
    scanf(&quot;%d%d%d&quot;,&amp;n, &amp;m, &amp;k);
    for(int i = 0; i &lt; m; i++){
        scanf(&quot;%d%d&quot;,&amp;a, &amp;b);
        G[a][b] = G[b][a] = 1;
    }
    for(int i = 0; i &lt; k; i++){
        fill(visit, visit + 1010, false);
        scanf(&quot;%d&quot;, &amp;a);
        int cnt = 0;
        visit[a] = true;
        for(int j = 1; j &lt;= n; j++){
            if(visit[j] == false){
                dfs(j);
                cnt++;
            }
        }
        printf(&quot;%d\n&quot;, cnt - 1);
    }
    return 0;
}</code></pre><p>2.A1021 Deepest Root。这道题注意用vector存储图的情况。连通分量的求法同1013.两次遍历就可以求出来所有最大深度的根  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; 
#include &lt;set&gt;
using namespace std;
int n, maxheight = 0;
vector&lt;vector&lt;int&gt; &gt; v;//用来存储图 
bool visit[10010];
set&lt;int&gt; s;
vector&lt;int&gt; temp;
void dfs(int node, int height){
    if(height &gt; maxheight){
        temp.clear();
        temp.push_back(node);
        maxheight = height;
    }else if(height == maxheight){
        temp.push_back(node);
    }
    visit[node] = true;
    for(int i = 0; i &lt; v[node].size(); i++){
        if(visit[v[node][i]] == false){
            dfs(v[node][i], height + 1);
        }
    }
}
int main(){
    scanf(&quot;%d&quot;, &amp;n);
    v.resize(n + 1);//必须要有 
    int cnt = 0, s1 = 0, a, b;
    for(int i = 0; i &lt; n - 1; i++){
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        v[a].push_back(b);
        v[b].push_back(a);
    }
    for(int i = 1; i &lt;= n; i++){
        if(visit[i] == false){
            dfs(i, 1);
            if(i == 1){
                if(temp.size() != 0) s1 = temp[0];
                for(int j = 0; j &lt; temp.size(); j++)
                    s.insert(temp[j]);
            }
            cnt++;
        }
    }
    if(cnt &gt;= 2){
        printf(&quot;Error: %d components&quot;, cnt);
    }else{
        temp.clear();
        maxheight = 0;
        fill(visit, visit + 10010, false);
        dfs(s1, 1);
        for(int i = 0; i &lt; temp.size(); i++)
            s.insert(temp[i]);
        for(auto it = s.begin(); it != s.end(); it++)
            printf(&quot;%d\n&quot;, *it);
    } 
    return 0;
}  </code></pre><p>3.A1103Integer Factorization 这道题要注意剪枝</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int n, k, p, maxFacSum = -1;
vector&lt;int&gt; v, ans, tempAns;
void init(){
    int temp = 0, index = 1;
    while(temp &lt;= n){
        v.push_back(temp);
        temp = pow(index, p);
        index++;
    }
}
void dfs(int index, int tempSum, int tempK, int facSum){
    if(tempK == k){
        if(tempSum == n &amp;&amp; facSum &gt; maxFacSum){
            ans = tempAns;//两个容器直接相等了
            maxFacSum = facSum; 
        }
        return;//表明得到了结果直接退出dfs 
    }
    while(index &gt;= 1){
        if(tempSum + v[index] &lt;= n){
            tempAns[tempK] = index;
            dfs(index, tempSum + v[index], tempK + 1, facSum + index);
        }
        if(index == 1) return;
        index--;
    } 
}
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n, &amp;k, &amp;p);
    init();
    tempAns.resize(k);
    dfs(v.size() - 1, 0, 0, 0);
    if(maxFacSum == -1){
        printf(&quot;Impossible&quot;);
        return 0;
    }
    printf(&quot;%d = &quot;, n);
    for(int i = 0; i &lt; ans.size(); i++){
        if(i != 0) printf(&quot; + &quot;);
        printf(&quot;%d^%d&quot;, ans[i], p);
    }
    return 0;
}</code></pre><p>4.A1131Subway Map 代码都看不懂  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;
vector&lt;vector&lt;int&gt; &gt; v(10000);
int visit[10000], minCnt, minTransfer, start, end1;
unordered_map&lt;int, int&gt; line;
vector&lt;int&gt; path, tempPath;
int transferCnt(vector&lt;int&gt; a){
    int cnt = -1, preLine = 0;//两个站相邻也需要一次换乘，preLine为0 
    for(int i = 1; i &lt; a.size(); i++){
        if(line[a[i-1]*10000+a[i]] != preLine) cnt++;
        preLine = line[a[i-1]*10000+a[i]];
    }
    return cnt;
} 
void dfs(int node, int cnt){
    if(node == end1 &amp;&amp; (cnt &lt; minCnt || (cnt == minCnt &amp;&amp; transferCnt(tempPath) &lt; minTransfer))){
        minCnt = cnt;
        minTransfer = transferCnt(tempPath);
        path = tempPath;
    }
    if(node == end1) return;//到了最后一个结点，直接退出
    for(int i = 0; i &lt; v[node].size(); i++){
        if(visit[v[node][i]] == 0){
            visit[v[node][i]] = 1;
            tempPath.push_back(v[node][i]);
            dfs(v[node][i], cnt + 1);
            visit[v[node][i]] = 0; 
            tempPath.pop_back();
        }
    } 
}
int main(){
    int n, m, k, pre, temp;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++){
        scanf(&quot;%d%d&quot;, &amp;m, &amp;pre);
        for(int j = 1; j &lt; m; j++){
            scanf(&quot;%d&quot;, &amp;temp);
            v[pre].push_back(temp);
            v[temp].push_back(pre);
            line[pre*10000+temp] = line[temp*10000+pre] = i+1;
            pre = temp;
        }
    }
    scanf(&quot;%d&quot;, &amp;k);
    for(int i = 0; i &lt; k; i++){
        scanf(&quot;%d%d&quot;, &amp;start, &amp;end1);
        minCnt = 99999, minTransfer = 99999;
        tempPath.clear();
        tempPath.push_back(start);
        visit[start] = 1;//设置第一项为已经访问，之后要清空 
        dfs(start, 0);
        visit[start] = 0;
        printf(&quot;%d\n&quot;, minCnt);
        int preLine = 0, preTransfer = start;
        for(int j = 1; j &lt; path.size(); j++){
            if(line[path[j-1]*10000+path[j]] != preLine){
                if(preLine != 0){
                    printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preLine, preTransfer, path[j-1]);
                }
                preLine = line[path[j-1]*10000+path[j]];
                preTransfer = path[j-1];
            }
        }
         printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preLine, preTransfer,end1);
    }
    return 0;
}  </code></pre><p>5.1130 Infix Expression (25分)  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
struct node {
    string data;
    int l, r;
}a[100];//任何一个结点都包括一个string数据，和两个int型孩子
string dfs(int root){

    if(a[root].l == -1 &amp;&amp; a[root].r != -1) return &quot;(&quot; + a[root].data + dfs(a[root].r) + &quot;)&quot;;

    if(a[root].l != -1 &amp;&amp; a[root].r != -1) return &quot;(&quot; + dfs(a[root].l) + a[root].data + dfs(a[root].r) + &quot;)&quot;;
    if(a[root].l == -1 &amp;&amp; a[root].r == -1) return a[root].data;//表示从叶子结点网上返回 
}

int main(){
    int n, judge[100] = {0}, root = 1;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++){
        cin &gt;&gt; a[i].data &gt;&gt; a[i].l &gt;&gt; a[i].r;
        if(a[i].l != -1) judge[a[i].l] = 1;
        if(a[i].r != -1) judge[a[i].r] = 1;
    }
    while(judge[root] == 1) root++;//用来计算根节点的序号。即所有的孩子结点都没有它 
    string ans = dfs(root);
    if(ans[0] == &apos;(&apos;) ans = ans.substr(1, ans.size() - 2);
    cout &lt;&lt; ans;

    return 0;
}   </code></pre><p>6.A1142 Maximal Clique (25分)</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int e[210][210];
int main(){
    int nv, ne, m, ta, tb, k;
    scanf(&quot;%d%d&quot;,&amp;nv, &amp;ne);
    for(int i = 0; i &lt; ne; i++){
        scanf(&quot;%d%d&quot;, &amp;ta, &amp;tb);
        e[ta][tb] = e[tb][ta] = 1; 
    }
    scanf(&quot;%d&quot;, &amp;m);
    for(int i = 0; i &lt; m; i++){
        scanf(&quot;%d&quot;, &amp;k);
        vector&lt;int&gt; v(k);//注意学习这种存储方式,表示大小为k 
        int hash[210] = {0}, isclique = 1, ismaximal = 1;
        for(int j = 0; j &lt; k; j++){
            scanf(&quot;%d&quot;,&amp;v[j]);//不需要设置临时变量，直接读入容器 
            hash[v[j]] = 1;//相当于vis 
        }

        for(int j = 0; j &lt; k; j++){
            if(isclique == 0) break;//再跳出来上一层循环 
            for(int l = j + 1; l &lt; k; l++){
                if(e[v[j]][v[l]] == 0){
                    isclique = 0;
                    printf(&quot;Not a Clique\n&quot;);
                    break;//只能跳出一层循环 
                }
            }
        } 

        if(isclique == 0) continue;//表示判断结束了，直接下一组数据 
        for(int j = 1; j &lt;= nv; j++){
            if(hash[j] == 0){
                for(int l = 0; l &lt; k; l++){
                    if(e[v[l]][j] == 0) break;
                    if(l == k - 1) ismaximal = 0;//表明里面的结点都选完了 
                }
            }
            if(ismaximal == 0){
                printf(&quot;Not Maximal\n&quot;);
                break;
            }
        }
        if(ismaximal == 1) printf(&quot;Yes\n&quot;);
    }    
    return 0;
}   </code></pre><p>7.1150 Travelling Salesman Problem (25分)  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;
int e[210][210], n, m, k, ans = 99999999, ansid;
vector&lt;int&gt; v;
void check(int index){
    int sum = 0, cnt, flag = 1;
    scanf(&quot;%d&quot;, &amp;cnt);
    set&lt;int&gt; s;
    vector &lt;int&gt; v(cnt);
    for(int i = 0; i &lt; cnt; i++){
        scanf(&quot;%d&quot;, &amp;v[i]);
        s.insert(v[i]);
    } 
    for(int i = 0; i &lt; cnt - 1; i++){
        if(e[v[i]][v[i+1]] == 0) flag =0;
        sum += e[v[i]][v[i+1]];
    }
    if(flag == 0){
        printf(&quot;Path %d: NA (Not a TS cycle)\n&quot;, index);    
    }else if(v[0] != v[cnt-1] || s.size() != n){
        printf(&quot;Path %d: %d (Not a TS cycle)\n&quot;, index, sum);
    }else if(cnt != n+1){//真是巧妙 
        printf(&quot;Path %d: %d (TS cycle)\n&quot;, index, sum);
        if(sum &lt; ans){
            ans = sum;
            ansid = index;
        }
    }else{
        printf(&quot;Path %d: %d (TS simple cycle)\n&quot;, index, sum);
         if (sum &lt; ans) {
             ans = sum;
             ansid = index;
         }
    }
}
int main(){
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 0; i &lt; m; i++){
        int t1, t2, t;
        scanf(&quot;%d%d%d&quot;, &amp;t1, &amp;t2, &amp;t);
        e[t1][t2] = e[t2][t1] = t;
    }
    scanf(&quot;%d&quot;, &amp;k);
    for(int i = 1; i&lt;= k; i++) check(i);
    printf(&quot;Shortest Dist(%d) = %d\n&quot;, ansid, ans);
    return 0;    
}  </code></pre><p>上面使用set来计算访问结点的个数真是巧妙，要学会；本题明显适应于使用函数的方法来解决问题，要有分段处理的思想；对于是不是旅行图的判断要认真学会。  </p>
<p>8.1122 Hamiltonian Cycle (25分)  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;
int G[210][210] = {0};
vector&lt;int&gt; path;
int main(){
    int n, m, ta, tb;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 0; i &lt; m; i++){
        scanf(&quot;%d%d&quot;, &amp;ta, &amp;tb);
        G[ta][tb] = G[tb][ta] = 1;
    }
    int k;
    scanf(&quot;%d&quot;, &amp;k);
    for(int i = 0; i &lt; k; i++){
        int n1, start, t;
        path.clear();
        set&lt;int&gt; s;
        scanf(&quot;%d%d&quot;, &amp;n1, &amp;start);
        path.push_back(start);
        for(int j = 0; j &lt; n1-1; j++){
            scanf(&quot;%d&quot;, &amp;t);
            path.push_back(t);
            s.insert(t);
        }
        int flag = 1;
        for(int j = 0; j &lt; n1 - 1; j++){
            if(G[path[j]][path[j+1]] == 0) flag = 0;
        }
//        cout &lt;&lt; flag &lt;&lt;&quot;$$&quot; &lt;&lt; endl;
        if(flag == 0){
            printf(&quot;NO\n&quot;);
            continue;
        }
        if(start == path[n1-1] &amp;&amp; s.size() == n &amp;&amp; n == n1-1) printf(&quot;YES\n&quot;);
        else printf(&quot;NO\n&quot;);
    }
    return 0;
} </code></pre><p>这是第一道自己做出来的图的题。注意使用数组的时候，一定要注意会不会越界，尤其是path[n-2]这样的情况，否则会出现段错误；这道题需要考虑道路走不通的情况；按照柳神的代码，优化的地方有：1.只有计数功能的循环，可以直接使用while(cnt–)这样的形式。2.分析问题的时候可以画出顺序图，这道题，多走，少走，或者成环设置成flag1， 道路走不通设置成flag2，逻辑就十分清晰。</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级学习笔记（四）</title>
    <url>/2020/02/24/PAT%E4%B9%99%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B)/</url>
    <content><![CDATA[<p>##续接PAT乙级学习笔记（三）<br>##以下PAT乙级其它题目<br>1.B1062最简分数。分数比较的时候可以使用交叉相乘的方法，不要想着使用double类型得到分数的小数形式比较大小。学会使用gcd求最大公倍数的递归写法，当成模板记住。数组定义的时候尽量初始化，不然按照判断数组的数是否为0就会出现错误。以下是代码<a id="more"></a>  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int gcd(int a, int b){
    if(b == 0) return a;
    else return gcd(b, a % b);
}
int main(){
    int n1, m1, n2, m2, k;
    scanf(&quot;%d/%d %d/%d %d&quot;,&amp;n1, &amp;m1, &amp;n2, &amp;m2, &amp;k);
    if(n1 * m2 &gt; n2 * m1){
        swap(n1, n2);
        swap(m1, m2);
    }
    int a[k] = {0};
    int cnt = 0;
    for(int i = 1; i &lt; k; i++){
        if(n1 * k &lt; m1 * i &amp;&amp; i * m2 &lt; k * n2 &amp;&amp; gcd(k, i) == 1){
            a[i] = i;
            cnt++;
        }
    }
    for(int i = 0; i &lt; k; i++){
        if(a[i] != 0){
            printf(&quot;%d/%d&quot;,a[i],k);
            if(--cnt &gt; 0) cout &lt;&lt; &quot; &quot;; 
        }
    }
    return 0;
}  </code></pre><p>注意体会柳神代码中输出空格的写法，相当于第一项不输出空格，其他的每一项都先输出空格再输出数</p>
<pre><code>bool flag = false;
    while(n1 * k &gt;= m1 * num) num++;
    while(n1 * k &lt; m1 * num &amp;&amp; m2 * num &lt; n2 * k) {
        if(gcd(num, k) == 1) {
            printf(&quot;%s%d/%d&quot;, flag == true ? &quot; &quot; : &quot;&quot;, num, k);
            flag = true;
        }
        num++;
    }  </code></pre><p>2.B1066图像过滤。这道题比较简单，下面是存储到数组中，统一输出的代码  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int m, n, a, b, c;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    int ans[m][n];
    for(int i = 0; i &lt; m; i++){
        for(int j = 0; j &lt; n; j++){
            scanf(&quot;%d&quot;, &amp;ans[i][j]) ;
            if(ans[i][j] &gt;= a &amp;&amp; ans[i][j] &lt;= b){
                ans[i][j] = c;
            }
        }
    }
    for(int i = 0; i &lt; m; i++){
        for(int j = 0; j &lt; n; j++){
            printf(&quot;%03d&quot;, ans[i][j]);
            if(j != n -1) cout &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}  </code></pre><p>下面是一边处理一边输出的代码  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int m, n, a, b, c;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    int ans[m][n];
    for(int i = 0; i &lt; m; i++){
        for(int j = 0; j &lt; n; j++){
            scanf(&quot;%d&quot;, &amp;ans[i][j]) ;
            if(ans[i][j] &gt;= a &amp;&amp; ans[i][j] &lt;= b){
                ans[i][j] = c;    
            }
            printf(&quot;%03d&quot;, ans[i][j]);
            if(j != n -1) cout &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}  </code></pre><p>3.B1071小赌怡情。较简单，注意游戏结束后要break退出  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int t0, k;
    cin &gt;&gt; t0 &gt;&gt; k;
    for(int i = 0; i &lt; k; i++){
        int n1, b, t, n2;
        cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2;
        if(t0 == 0){
            printf(&quot;Game Over.\n&quot;);
            break;
        }
        else{
            if(t0 &lt; t) printf(&quot;Not enough tokens.  Total = %d.\n&quot;,t0);
            else{
                if(b == 0 &amp;&amp; n2 &lt; n1 || b == 1 &amp;&amp; n2 &gt; n1){
                    t0 = t0 + t;
                    printf(&quot;Win %d!  Total = %d.\n&quot;,t,t0);
                }
                else{
                    t0 = t0 - t;
                    printf(&quot;Lose %d.  Total = %d.\n&quot;,t,t0);
                }
            }    
        }
    }
    return 0;
}  </code></pre><p>4.B1072开学寄语。属于简单题，注意变量定义的位置。一定要注意“=”和“==”的区别!!!数组初始化如果全部赋值为0可以直接用={0}来赋值，如果赋值为其他数，需要使用循环或者按照本题目中的做法：  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int check[10000] = {0};
int main(){
    int n, m, cnt0 = 0, cnt1 = 0;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i++){
        int temp;
        cin &gt;&gt; temp;
        check[temp] = 1;
    }
    for(int i = 0; i &lt; n; i++){
        string name;
        int k,flag = 0;
        cin &gt;&gt; name &gt;&gt; k;
        int ans[11] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}; 
        for(int j = 0; j &lt; k; j++){
            int temp1;
            cin &gt;&gt; temp1;
            if(check[temp1] == 1){
                flag =1;
                ans[j] = temp1;
                cnt1++;
            }
        }
        if(flag == 1){
            cnt0++;
            bool space = false;
            cout &lt;&lt; name &lt;&lt;&quot;: &quot;;
            for(int j = 0; j &lt; k; j++){
                if(ans[j] != -1){
                    if(space == true) cout &lt;&lt; &quot; &quot;;
                    printf(&quot;%04d&quot;,ans[j]);
                    space = true;
                }
            }
            cout &lt;&lt; endl;        
        }
    }
    cout &lt;&lt; cnt0 &lt;&lt; &quot; &quot; &lt;&lt; cnt1;
    return 0;
}  </code></pre><p>柳神的代码不太好理解，这里有一个技巧就是，输出名字后，其实每一个违禁品编号前面都有有个空格。对于输出也是只有第一个前面输出名字，其他的都不输出。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
bool forbid[10000];
int main() {
    int n, m, temp, k, snum = 0, fnum = 0;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; m; i++) {
        scanf(&quot;%d&quot;, &amp;temp);
        forbid[temp] = true;
    }
    for (int i = 0; i &lt; n; i++) {
        char name[10];
        bool flag = false;
        scanf(&quot;%s %d&quot;, name, &amp;k);
        for (int j = 0; j &lt; k; j++) {
            scanf(&quot;%d&quot;, &amp;temp);
            if (forbid[temp]) {
                if (!flag) {
                    printf(&quot;%s:&quot;, name);
                    flag = true;
                }
                printf(&quot; %04d&quot;, temp);
                fnum++;
            }
        }
        if (flag) {
            printf(&quot;\n&quot;);
            snum++;
        }
    }
    printf(&quot;%d %d\n&quot;, snum, fnum);
    return 0;
}  </code></pre><p>5.B1076Wifi密码。这道题相对简单，注意使用scanf以%c的形式是可以读入空格和换行的。使用getline之前必须使用getline来吸收一下。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main(){
    int n;
    cin &gt;&gt; n;
    getchar();
    string s;
    for(int i = 0; i &lt; n; i++){
        getline(cin, s);
        for(int j = 0; j &lt; s.length(); j++){
            if(s[j] == &apos;-&apos; &amp;&amp; s[j + 1] == &apos;T&apos;){
                cout &lt;&lt; s[j - 1] - &apos;A&apos; + 1; 
            }    
        }    
    } 
    return 0;
}  </code></pre><p>注意柳神中while的写法，真的太巧妙了  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    string s;
    while (cin &gt;&gt; s) 
        if(s.size() == 3 &amp;&amp; s[2] == &apos;T&apos;) cout &lt;&lt; s[0]-&apos;A&apos;+1;
    return 0;
}  </code></pre><p>6.B1077互评成绩。注意变量定义后的作用范围，这道题vector需要定义在数组以内，如果定义在外面出错，相当于每个循环都初始化一次。四舍五入就是要加上0.5后得到整数。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;
int main(){
    int n, m;
    double g1, g2;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; g1;
        vector&lt;int&gt; v;
        for(int j = 1; j &lt; n; j++){
            int temp;
            cin &gt;&gt; temp;
            if(temp &gt;= 0 &amp;&amp; temp &lt;= m){
                v.push_back(temp);
            }
        }
        int sum = 0;
        sort(v.begin(),v.end());
        for(int i = 1; i &lt; v.size() - 1; i++){
            sum += v[i];
        }    
        double g2 = sum / (v.size() - 2) ;
        cout &lt;&lt; (int)((g1 + g2) / 2 + 0.5) &lt;&lt; endl;
    }
    return 0;
}  </code></pre><p>7.B1087有多少不同的值。是一道简单题，使用set可以大大减少代码量  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;
int main(){
    int n;
    cin &gt;&gt; n;
    set&lt;int&gt; st;
    for(int i = 0; i &lt;= n; i++){
        int temp = (i / 2) + (i / 3) + (i / 5);
        st.insert(temp);
    }
    cout &lt;&lt; st.size();
    return 0;
}  </code></pre><p>8.B1020月饼。注意需要按照单价排序，不是按照价格排序。注意是正数还是正正数。需要考虑所有都不满足的情况。下面是代码  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;
struct node{
    double total, sumprice,price;
};
bool cmp(node a, node b){
        return a.price &gt; b.price;
}
int main(){
    int n, d;
    cin &gt;&gt; n &gt;&gt; d;
    vector &lt;node&gt; v(n);
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].total;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].sumprice;
    for(int i = 0; i &lt; n; i++){
        v[i].price = v[i].sumprice * 1.0 / v[i].total;
    } 
    sort(v.begin(),v.end(),cmp);
//    for(int i = 0; i &lt; n; i++) cout &lt;&lt; v[i].total &lt;&lt;&quot;*&quot;&lt;&lt; v[i].price &lt;&lt; endl;
    double sum = 0;
    int i = 0;
    while(d &gt; 0 &amp;&amp; i &lt; n){
//        cout &lt;&lt; v[i].total &lt;&lt; v[i].price &lt;&lt; endl;
        if(d &gt;= v[i].total){
            sum += v[i].sumprice;
        }
        else{
            sum += (d * v[i].sumprice * 1.0/ v[i].total);
        }
        d = d - v[i].total;
        i++;
    }
    int tmp = 0;
    for(int i = 0; i &lt; n; i++){
            tmp += v[i].sumprice;
        }
    if(d &gt; tmp) cout &lt;&lt; tmp;
    else printf(&quot;%.2f&quot;, sum);
    return 0;
}  </code></pre><p>注意柳神代码中的算法：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
struct mooncake{
    float mount, price, unit;
};
int cmp(mooncake a, mooncake b) {
    return a.unit &gt; b.unit;
}
int main() {
    int n, need;
    cin &gt;&gt; n &gt;&gt; need;
    vector&lt;mooncake&gt; a(n);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%f&quot;, &amp;a[i].mount);
    for (int i = 0; i &lt; n; i++) scanf(&quot;%f&quot;, &amp;a[i].price);
    for (int i = 0; i &lt; n; i++) a[i].unit = a[i].price / a[i].mount;
    sort(a.begin(), a.end(), cmp);
    float result = 0.0;
    for (int i = 0; i &lt; n; i++) {
        if (a[i].mount &lt;= need) {
            result = result + a[i].price;
        } else {
            result = result + a[i].unit * need;
            break;
        }
        need = need - a[i].mount;
    }
    printf(&quot;%.2f&quot;,result);
    return 0;
}  </code></pre><p>9.B1068万绿丛中一点红。这道题参考了柳神的代码，注意容器的resize的用法，为重新指定有效元素的个数，当定义两个变长的二维数组的时候，需要这样定义。vector&lt;vector<int>&gt; v(m)这样定义时表示，其中一个维度已经确定了。<br>10.B1070结绳。这道题题目读不懂，所以导致做不出来，不过思路是对的，浮点数与正数相加是浮点数。  </int></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int n;
    cin &gt;&gt; n;
    int a[n];
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
    sort(a, a + n);
    double ans = a[0];
    for(int i = 1; i &lt; n; i++){
        ans = (ans + a[i]) / 2;
    }
    printf(&quot;%d&quot;, (int)ans);
    return 0;
}   </code></pre><p>10.B1045快速排序。这道题注意思路。一个数如果按照从小到大的顺序排列后，它的位置和源位置一样，并且大于左边的最大数，这个数就是主元。（另外一种思路是遍历数组，用一个数组来存储这个数左边的最大数，包括自己，遍历右边的数组，用一个数组存储这个数右边的最小数，包括自己，然后再遍历数组后，经过比较，找到主元。）注意当没有主元的时候，为了体现出第二行，需要输出换行符  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int v[100000];
int main(){
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    vector&lt;int&gt; a(n), b(n);
    for(int i = 0; i &lt; n; i++) {
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[i] = a[i];
    }
    int max = 0, cnt = 0;
    sort(b.begin(),b.end());
    for(int i = 0; i &lt; n; i++){
        if(a[i] == b[i] &amp;&amp; a[i] &gt; max){
            v[cnt++] = a[i]; 
        }
        if(a[i] &gt; max)
            max = a[i];
    } 
    printf(&quot;%d\n&quot;, cnt);
    for(int i = 0; i &lt; cnt; i++){
        printf(&quot;%d&quot;, v[i]);
        if(i != cnt - 1) printf(&quot; &quot;);
    }
    printf(&quot;\n&quot;);
    return 0;
}</code></pre><p>11.B1075链表元素分类。这道题相当于一个模板，用node结构体来存储每一个链表结点的数据和下一个地址，另定义为list[100000]，list的下标就是地址。输入的时候本结点的地址就相当于是临时变量，存储进list结构体里面。遍历的时候注意使用的是while循环，设定临时指针等于第一个地址（start）当p != -1的时候作为遍历条件，结尾组不要忘记p指向下一个地址。输出时第一个结点只输出本结点地址和数据，其他的结点输出一个本结点地址，换行，再输出一个本结点地址，再输出本结点数据，最后的时候不要忘记输出最后结点的下一个地址为-1.本道题和1025反转链表一个采用顺序存储，一个采用链式存储，需要多注意。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
struct node{
    int data,next;
}list[100000]; 
vector &lt;int&gt; v[3];
int main(){
    int start, n, k, a;
    scanf(&quot;%d %d %d&quot;, &amp;start, &amp;n, &amp;k);
    for(int i = 0; i &lt; n; i++){
        scanf(&quot;%d&quot;, &amp;a);
        scanf(&quot;%d%d&quot;, &amp;list[a].data, &amp;list[a].next);
    }
    int p = start;
    while(p != -1){
        int data = list[p].data;
        if(data &lt; 0)
            v[0].push_back(p);
        else if(data &gt;= 0 &amp;&amp; data &lt;= k)
            v[1].push_back(p);
        else
            v[2].push_back(p);
        p = list[p].next;
    }
    int flag = 0;
    for(int i = 0; i &lt; 3; i++){
        for(int j = 0; j &lt; v[i].size(); j++){
            if(flag == 0){
                printf(&quot;%05d %d&quot;, v[i][j], list[v[i][j]].data);
                flag = 1;
            }else{
                printf(&quot; %05d\n%05d %d&quot;,v[i][j], v[i][j], list[v[i][j]].data);
            }
        }
    } 
    printf(&quot; -1&quot;);    
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级英语单词记录</title>
    <url>/2020/02/24/PAT%E7%94%B2%E7%BA%A7%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>##记录一下PAT甲级中遇到的不认识的英语单词：<br>1.sublist 子列表<br>2.suffix 后缀<br>3.positive 正数<br>4.integer 整数<br>5.format 格式  <a id="more"></a><br>6.deduplication 重复数据删除<br>7.duplication 不必要的，重复的<br>8.absolute 绝对的，绝对值<br>9.separate 单独的<br>10.acyclic 无环的<br>11.syntax 语法<br>12.binary 二叉，二进制的<br>13.corresponding 相应的<br>14.infix 中缀<br>15.parentheses  圆括号<br>16.precedence  优先级<br>17.indices  索引，指示<br>18.monitor  监控，监管<br>19.capaticy  容器，容量<br>20.negative  负的</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级学习笔记（三）</title>
    <url>/2020/02/19/PAT%E4%B9%99%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>##续接PAT乙级学习笔记（二）<br>##以下PAT乙级其它题目<br>1.B1015德才论。对于这样的有多数据的比较，先建立结构体，然后写好cmp函数，注意函数一定要写return！！！看题目的时候一定要注意哪些是大于，不大于，哪些是小于，不小于！！<a id="more"></a>  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
string name;
int de, cai, sum;
};
int cmp(node a, node b){
if(a.sum != b.sum) 
    return a.sum &gt; b.sum;
else if(a.de != b.de) 
    return a.de &gt; b.de;
else 
    return a.name &lt; b.name;
}
vector&lt;node&gt; v[4];
int main(){
int n, l, h;
cin &gt;&gt; n &gt;&gt; l &gt;&gt; h;
int d, c, cnt = n;
for(int i = 0; i &lt; n; i++){
    string s;
    cin &gt;&gt; s &gt;&gt; d &gt;&gt; c;
    if(d &lt; l || c &lt; l) cnt--;
    else if(d &gt;= h &amp;&amp; c &gt;= h){
        v[0].push_back(node{s, d, c, d + c});
    }
    else if(d &gt;= h &amp;&amp; c &lt; h ){
        v[1].push_back(node{s, d, c, d + c});
    }
    else if(d &lt; h &amp;&amp; c &lt; h &amp;&amp; d &gt;= c){
        v[2].push_back(node{s, d, c, d + c});
    }
    else 
        v[3].push_back(node{s, d, c, d + c});
}

cout &lt;&lt; cnt &lt;&lt; endl;
for( int i = 0; i &lt; 4; i++){
    sort(v[i].begin(),v[i].end(),cmp);
    for(int j = 0; j &lt; v[i].size(); j++)
        printf(&quot;%s %d %d\n&quot;,v[i][j].name.c_str(), v[i][j].de, v[i][j].cai);
}
return 0;
}   </code></pre><p>2.B1017A除以    B。跌跌撞撞的把题做出来了，但是代码冗长不精简，下面是我的代码：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
string a;
int b; 
cin &gt;&gt; a &gt;&gt; b;
int len = a.length();
int q[len],r = 0;
for(int i = 0; i &lt; len; i++){
    r = r * 10 + a[i]-&apos;0&apos;; 
    if(r &lt; b) q[i] = 0;
    else{
        q[i] = r / b;
        r = r % b;
    }
}
if(len == 1 &amp;&amp; a[0] - &apos;0&apos; &lt; b){
    cout &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; r;
    return 0;
}
int pos = 0;
for(int i = 0; i &lt; len; i++){
    if(q[i] == 0) pos++;
    else break;
}
for(int i = pos; i &lt; len; i++){
     cout &lt;&lt; q[i];
}
cout &lt;&lt; &quot; &quot; &lt;&lt; r;
return 0;
}   </code></pre><p>下面是柳神的代码，真的十分精简并且一气呵成！！！</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
string s;
int a, t = 0, temp = 0;
cin &gt;&gt; s &gt;&gt; a;
int len = s.length();
t = (s[0] -  &apos;0&apos;) / a;
//下面表示先特殊处理一下第一位 
if((t != 0 &amp;&amp; len &gt; 1) || len == 1)
    cout &lt;&lt; t;
//下面表示处理其它位
temp = (s[0] - &apos;0&apos;) % a;
for(int i = 1; i &lt; len; i++){
    t = (temp * 10 + s[i] - &apos;0&apos;) / a;
    cout &lt;&lt; t;
    temp = (temp * 10 + s[i] - &apos;0&apos;) % a;
} 
cout &lt;&lt; &quot; &quot; &lt;&lt; temp;
return 0;
}   </code></pre><p>3.BD进制的A+B。这道题注意柳神代码中如何反向输出数组中的元素，将i设为全局变量，循环的时候使用whil循环，代码更加精简。<br>    #include<iostream><br>    #include<set><br>    #include<string><br>    #include<vector><br>    #include<algorithm><br>    using namespace std;<br>    int main(){<br>    int a, b, d;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;<br>    int t = a + b;<br>    if(t == 0) {<br>        cout &lt;&lt; 0;<br>        return 0;<br>    }<br>    int s[100];<br>    int i = 0;<br>    while(t != 0){<br>        s[i++] = t % d;<br>        t = t / d;<br>    }<br>    for(int j = i - 1; j &gt;= 0; j–){<br>        cout &lt;&lt; s[j];<br>    }<br>    return 0;<br>    }<br>4.B1023组个最小的数。这道题相对简单，感觉我的做法要比柳神的更好理解一些，代码长度差不多：  </algorithm></vector></string></set></iostream></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
int a[10];
for(int i = 0; i &lt; 10; i++){
    scanf(&quot;%d&quot;,&amp;a[i]);    
}
if(a[0] != 0){
    for(int j = 1; j &lt; 10; j++){
        if(a[j] &gt; 0){
            cout &lt;&lt; j;
            a[j]--;
            break;
        }
    }
}
for(int i = 0; i &lt; 10; i++){
    while(a[i]-- &gt; 0) cout &lt;&lt; i;
}
return 0;
}   </code></pre><p>5.B1027打印沙漏。这道题参考的柳神的代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
int N, row = 0;
char c;
cin &gt;&gt; N &gt;&gt; c;
for (int i = 0; i &lt; N; i++) {
    if ((2 * i * (i + 2) + 1) &gt; N) {
        row = i - 1;
        break;
    }
}
for (int i = row; i &gt;= 1; i--) {
    for (int k = row - i; k &gt;= 1; k--) cout &lt;&lt; &quot; &quot;;
    for (int j = i * 2 + 1; j &gt;= 1; j--) cout &lt;&lt; c;
    cout &lt;&lt; endl;
}
for (int i = 0; i &lt; row; i++) cout &lt;&lt; &quot; &quot;;
cout &lt;&lt; c &lt;&lt; endl;
for (int i = 1; i &lt;= row; i++) {
    for (int k = row - i; k &gt;= 1; k--) cout &lt;&lt; &quot; &quot;;
    for (int j = i * 2 + 1; j &gt;= 1; j--) cout &lt;&lt; c;
    cout &lt;&lt; endl;
}
cout &lt;&lt; (N - (2 * row * (row + 2) + 1));
return 0;
}  </code></pre><p>6.B1028人口普查。这道题注意，先设置最大和最小的极限情况，然后一一遍历，得出情况。判断是否合法可以使用一个函数来实现，注意当没有合法生日的时候，不应该输出名字！！！我的代码如下：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool isright(int y, int m, int d){
if(y &gt; 2014 || y == 2014 &amp;&amp; m &gt; 9 || y == 2014 &amp;&amp; m == 9 &amp;&amp; d &gt; 6){
    return false;
}
else if(y &lt; 1814 || y == 1814 &amp;&amp; m &lt; 9 || y == 1814 &amp;&amp; m == 9 &amp;&amp; d &lt; 6){
    return false;
} 
else return true;
}
int main(){
int n,cnt = 0;
string s, maxs, mins;
int y, m, d, maxy = 2014 , maxm = 9, maxd = 6, miny = 1814, minm = 9, mind = 6;
cin &gt;&gt; n;
for(int i = 0; i &lt; n; i++){
    cin &gt;&gt; s;
    scanf(&quot;%d/%d/%d&quot;, &amp;y, &amp;m, &amp;d);
    if(isright(y, m, d)){
        cnt++;
        if(y &gt; miny || y == miny  &amp;&amp; m &gt; minm || y == miny &amp;&amp; m == minm &amp;&amp; d &gt; mind){
            mins = s;
            miny = y;
            minm = m;
            mind = d;
        }
        if(y &lt; maxy || y == maxy  &amp;&amp; m &lt; maxm || y == maxy &amp;&amp; m == maxm &amp;&amp; d &lt; maxd){
            maxs = s;
            maxy = y;
            maxm = m;
            maxd = d;
        }
    }    
} 
if(cnt == 0) cout &lt;&lt; 0;
else cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; maxs &lt;&lt; &quot; &quot; &lt;&lt; mins;
return 0;
} </code></pre><p>看完柳神的代码，真的自叹不如。判断生日大小直接采用字符串比较，我还多写了一个函数，还要分情况讨论，代码写的真的冗长，附上柳神的代码：  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
int n, cnt = 0;
cin &gt;&gt; n;
string name, birth, maxname, minname, maxbirth = &quot;1814/09/06&quot;, minbirth = &quot;2014/09/06&quot;;
for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; name &gt;&gt; birth;
    if (birth &gt;= &quot;1814/09/06&quot; &amp;&amp; birth &lt;= &quot;2014/09/06&quot;) {
        cnt++;
        if (birth &gt;= maxbirth) {
            maxbirth = birth;
            maxname = name;
        }
        if (birth &lt;= minbirth) {
            minbirth = birth;
            minname = name;
        }
    }
}
cout &lt;&lt; cnt;
if (cnt != 0) cout &lt;&lt; &quot; &quot; &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; maxname;
return 0;
}  </code></pre><p>7.B1030完美数列。这道题注意溢出的情况int最多2*10^9，所以p要设置为lonlong类型，要是超时的时候可以考虑两个for循环的代码优化，外层for循环不优化也可以，因为如果条件不满足没有语句执行，思考问题的时候最好是正向思维，避免出错，如果j从最后一项开始遍历，就比较乱    </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
int n;
long p;
cin &gt;&gt; n &gt;&gt; p;
int a[n];
for(int k = 0; k &lt; n; k++){
    scanf(&quot;%d&quot;,&amp;a[k]);
} 
sort(a,a + n);
int maxcnt = 0,temp = 0;
for(int i = 0; i &lt;= n; i++){
    for(int j = i + maxcnt; j &lt; n; j++){
        if(a[j] &lt;= p * a[i]){
            temp = j - i + 1;
            if(temp &gt; maxcnt) maxcnt = temp;
        }
        else break;    
    }    
}
cout &lt;&lt; maxcnt;
return 0;
}  </code></pre><p>8.B1032挖掘机技术哪家强。这道题比较简单，注意审题，题目中说没有重复并列，学校序号从0开始连续编号，所以简单不少，注意柳神当中把最大值当做第一个，遍历从第二项开始遍历的写法，下面是我的代码：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
    int n;
    cin &gt;&gt; n;
    int a[n + 1] = {0};
    for(int i = 0; i &lt; n; i++ ){
        int sch, score;
        cin &gt;&gt; sch &gt;&gt; score;
        a[sch] += score;
    } 
    int max = 0,t = 0;
    for(int i = 1; i &lt;= n; i++){
        if(a[i] &gt;= max){
            max = a[i];
            t = i;    
        }
    }
cout &lt;&lt; t &lt;&lt; &quot; &quot;&lt;&lt; max;
return 0;
}  </code></pre><p>9.B1036跟奥巴马一起学编程。这道题相对简单，注意每一列之间没有空格，就直接是换行，下面是代码：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
    int n;
    char c;
    cin &gt;&gt; n &gt;&gt; c;
    int row = n % 2 == 0 ? n / 2 : n / 2 + 1;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; c;
    cout &lt;&lt; endl;
    for(int i = 0; i &lt; row - 2; i++){
        cout &lt;&lt; c;
        for(int j = 0; j &lt; n - 2; j++) cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c &lt;&lt; endl;
    }
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; c;
return 0;
}  </code></pre><p>注意体会柳神代码中如何分类奇数和偶数的写法,真的是比我的简单多了<br><code>int t = N / 2 + N % 2;</code>  </p>
<p>10.B1037在霍格沃茨找零钱。这道题比较简单，看成是计算时间的那道题即可，下面是代码：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
    int g1, s1, k1, g2, s2, k2;
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;g1, &amp;s1, &amp;k1, &amp;g2, &amp;s2, &amp;k2);
    int a, b;
    a = g1 * 17 * 29 + s1 *29 + k1;
    b = g2 * 17 * 29 + s2 *29 + k2;
    int ans;
    if(a &gt; b){
        cout &lt;&lt; &quot;-&quot;;
        ans = a - b;
    }
    else ans = b - a;
    int g, s, k;
    g = ans / (17 * 29);
    s = (ans - g * 17 *29) / 29;
    k = ans - g * 17 * 29 - s *29;
    cout &lt;&lt; g &lt;&lt; &quot;.&quot; &lt;&lt; s &lt;&lt; &quot;.&quot; &lt;&lt; k;
    return 0;
}  </code></pre><p>看了柳神的代码，采用模拟减法运算的方法，简直是太妙了!,附上柳神的代码  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int a, b ,c, m, n, t, x, y, z;
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a, &amp;b, &amp;c, &amp;m, &amp;n, &amp;t);
    if (a &gt; m || (a == m &amp;&amp; b &gt; n) || (a == m &amp;&amp; b == n &amp;&amp; c &gt; t)) {
        swap(a, m); swap(b, n); swap(c, t);
        printf(&quot;-&quot;);        
    }
    z = t &lt; c ? t - c + 29 : t - c;
    n = t &lt; c ? n - 1 : n;
    y = n &lt; b ? n - b + 17 : n - b;
    x = n &lt; b ? m - a - 1 : m - a;
    printf(&quot;%d.%d.%d&quot;, x, y, z);
    return 0;
}  </code></pre><p>11.B1041考试座位号。注意如果没有使用循环中的i作为循环体内的数据的时候，尽量让i从0开始，下面是我的代码，这道题和mooc考试成绩，危险品装箱题型类似，注意体会：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
struct node{
    string id;
    int a, b;
};
int main(){
    int n;
    cin &gt;&gt; n;
    vector&lt;node&gt; v;
    for(int i = 0; i &lt; n; i++){
        string s;
        int a, b;
        cin &gt;&gt; s &gt;&gt; a &gt;&gt; b;
        v.push_back(node{s, a, b});
    }
    int m;
    cin &gt;&gt; m;
    for(int j = 0; j &lt; m; j++){
        int temp;
        cin &gt;&gt; temp;
        for(int i = 0; i &lt; n; i++){
            if(v[i].a == temp) cout &lt;&lt; v[i].id &lt;&lt; &quot; &quot; &lt;&lt; v[i].b &lt;&lt; endl;
        }
    } 
return 0;
}  </code></pre><p>柳神采用的是string类型的二维数组，更加简单！！ </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    string stu[1005][2], s1, s2;;
    int n, m, t;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; s1 &gt;&gt; t &gt;&gt; s2;
        stu[t][0] = s1;
        stu[t][1] = s2; 
    } 
    cin &gt;&gt; m;
    for(int i = 0; i &lt; m; i++) {
        cin &gt;&gt; t;
        cout &lt;&lt; stu[t][0] &lt;&lt; &quot; &quot; &lt;&lt; stu[t][1] &lt;&lt; endl;
    } 
    return 0;
}  </code></pre><p>12.B1055集体照。结构体定义struct要放在cmp之前。输入结构体可以直接cin&gt;&gt;v[i].name，不需要临时变量，然后push_back(node{s,a})。注意体会柳神代码中的空格的输出方式。就是先输出第一项，然后输出空格加第i项。将整个题目转换为不同人数的行的计算，不用分类讨论更简单。先左后右不递增就是排序中每隔一个一输出。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
struct node{
    string name;
    int high;
}; 
bool cmp1(struct node a,struct node b){
    if(a.high != b.high) return a.high &gt; b.high;
    else return a.name &lt; b.name; 
}
int main(){
    int n, k, m;
    cin &gt;&gt; n &gt;&gt; k;
    vector &lt;node&gt; v(n);
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; v[i].name;
        cin &gt;&gt; v[i].high;
    } 
    sort(v.begin(),v.end(),cmp1);
    int t = 0, row = k;//t是v的下标，是每一排起始的数 
    while(row){
        if(row == k)
            m = n - n / k * (k - 1);
        else 
            m = n / k;

        vector&lt;string&gt; ans(m);
        ans[m / 2] = v[t].name;

        int j = m / 2 - 1;
        for(int i = t + 1; i &lt; t + m; i = i + 2) 
            ans[j--] = v[i].name;

        j = m / 2 + 1;
        for(int i = t + 2; i &lt; t + m; i = i + 2)
            ans[j++] = v[i].name;

        cout &lt;&lt; ans[0];
        for(int i = 1; i &lt; m; i++)
            cout &lt;&lt; &quot; &quot; &lt;&lt; ans[i];
        cout &lt;&lt; endl;
        t = t + m;
        row--; 
    }    
    return 0;
}  </code></pre><p>13.B1057数零壹。这道题比较简单，注意十进制如何转换为二进制，方法要注意，当和为零的时候，应该输出0 0，下面是代码：  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;
using namespace std;
int main(){
    string s;
    getline(cin,s);
    int sum = 0;
    for(int i = 0; i &lt; s.length(); i++){
        if(isalpha(s[i])){
            s[i] = tolower(s[i]);
            sum += s[i] - &apos;a&apos; + 1;
        }
    } 
    int a = 0, b = 0;
        while(sum != 0){
            if(sum % 2 == 0) a++;
            else b++;
            sum /= 2; 
        }
        cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b;
    return 0;
}  </code></pre><p>14.B1061判断题。水题，比较简单，注意写的时候认真点：  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main(){
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    int score[m], right[m];
    for(int i = 0; i &lt; m; i++) cin &gt;&gt; score[i];
    for(int i = 0; i &lt; m; i++) cin &gt;&gt; right[i];
    int sum[n] = {0};
    for(int i = 0; i &lt; n; i++){
        for(int j = 0; j &lt; m; j++){
            int a;
            cin &gt;&gt; a;
            if(a == right[j]) sum[i] += score[j];
        }
        cout &lt;&lt; sum[i] &lt;&lt; endl;
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列</title>
    <url>/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是一种先进先出（FIFO)的数据结构，下面是循环队列顺序存储方式<a id="more"></a>  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int QElemType;

// 循环队列的顺序结构
typedef struct{
QElemType data[MAXSIZE];
int front;
int rear; 
}SqQueue;

Status visit(QElemType c){
printf(&quot;%d &quot;, c);
return OK;
}
//初始化一个空队列
Status InitQueue(SqQueue *Q){
Q-&gt;front = 0;
Q-&gt;rear = 0;
return OK; 
} 

//将Q清空
Status ClearQueue(SqQueue *Q){
Q-&gt;front = Q-&gt;rear = 0;
return OK;
} 

//判断是否为空 
Status QueueEmpty(SqQueue Q){
if(Q.front == Q.rear)
    return TRUE;
else
    return FALSE;
} 

//返回Q元素的个数
int QueueLength(SqQueue Q){
return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
} 

//用e返回队列的队头元素
Status GetHead(SqQueue Q, QElemType *e){
if(Q.front == Q.rear)
    return ERROR;
*e = Q.data[Q.front];
return OK;
} 

//插入新的元素e
Status EnQueue(SqQueue *Q, QElemType e){
if((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)
    return ERROR;
    Q-&gt;data[Q-&gt;rear] = e;
    Q-&gt;rear = (Q-&gt;rear + 1)%MAXSIZE;
    return OK;
} 

//删除队头元素，用e返回
Status DeQueue(SqQueue *Q, QElemType *e){
if(Q-&gt;front == Q-&gt;rear)
    return ERROR;
*e = Q-&gt;data[Q-&gt;front];
Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;
return OK;
} 

//从队头到队尾依次输出
Status QueueTraverse(SqQueue Q){
int i;
i = Q.front;
while((i + Q.front) != Q.rear){
    visit(Q.data[i]);
    i = (i + 1) % MAXSIZE;
}
printf(&quot;\n&quot;);
return OK;
} 
int main(){
Status j;
int i = 0, l;
QElemType d;
SqQueue Q;
InitQueue(&amp;Q);
//%u表示无符号的十进制整数 
printf(&quot;初始化队列后，队列空否？%u(1:空 0:否)\n&quot;,QueueEmpty(Q));
printf(&quot;请输入整型队列元素(不超过%d个),-1为提前结束符: &quot;,MAXSIZE-1);
do{
    d = i + 100;
    if(d == -1)
        break;
    i++;
    EnQueue(&amp;Q,d); 
}while(i &lt; MAXSIZE - 1);
printf(&quot;队列长度为: %d\n&quot;,QueueLength(Q));
printf(&quot;现在队列空否？%u(1:空 0:否)\n&quot;,QueueEmpty(Q));
printf(&quot;连续%d次由队头删除元素,队尾插入元素:\n&quot;,MAXSIZE);
for(l = 1; l &lt;= MAXSIZE; l++){
    DeQueue(&amp;Q,&amp;d);
    printf(&quot;删除的元素是%d，插入的元素是：%d\n&quot;,d,l+1000);
    d = l + 1000;
    EnQueue(&amp;Q, d);
}
l = QueueLength(Q);
printf(&quot;现在的队列元素为：\n&quot;);
QueueTraverse(Q);
printf(&quot;共向队尾插入了%d个元素\n&quot;,i+MAXSIZE);
if(l - 2 &gt; 0)
    printf(&quot;现在由队头删除了%d个元素\n&quot;,l - 2);
while(QueueLength(Q)&gt;2){
    DeQueue(&amp;Q,&amp;d);
    printf(&quot;删除的元素为%d\n&quot;,d);
}
j = GetHead(Q,&amp;d);
if(j)
    printf(&quot;现在队头元素为：%d\n&quot;,d);
    ClearQueue(&amp;Q);
    printf(&quot;清空队列后，队列空否？%u(1:空 0：否)\n&quot;,QueueEmpty(Q));
    return 0;
}   </code></pre><p>下面是链队列的代码方式</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int QElemType;

typedef struct QNode //用于定义链的结点 
{
   QElemType data;//定义结点的数据域 
   struct QNode *next;//定义 结点的指针域 
}QNode,*QueuePtr;//定义一个可以定义结点的名称，定义一个指    向结点的指针 

typedef struct        //定义链表的结构，包含两个结点指针    
{
 QueuePtr front,rear; 
}LinkQueue;

Status visit(QElemType c)//用于访问结点的数据域 
{
printf(&quot;%d &quot;,c);
return OK;
}

/* 构造一个空队列Q */
Status InitQueue(LinkQueue *Q)
{ 
Q-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));
//申请大小为结点结构的动态空间，第一个括号为指向结点指针，第二个括号为结点大小 
if(!Q-&gt;front)
    exit(OVERFLOW);
//xit(OVERFLOW)的含义就是，退出程序，并返回OVERFLOW的值给主调进程。
//其标准的使用范围为，当程序运算出现上溢时，退出程序并报错给主调进程。
Q-&gt;front-&gt;next=NULL;//头指针为栈顶 
return OK;
}

/* 销毁队列Q，就是什么都没有了 ，头结点都释放掉了*/
Status DestroyQueue(LinkQueue *Q)
{
while(Q-&gt;front)
{
     Q-&gt;rear=Q-&gt;front-&gt;next;
     //这里的Q-&gt;rear当一个临时指针使用取出一个头指针指向的结点free一个 
     free(Q-&gt;front);
     Q-&gt;front=Q-&gt;rear;
}
return OK;
}

/* 将Q清为空队列，头指针尾指针还在，都指向头结点 */
Status ClearQueue(LinkQueue *Q)
{
QueuePtr p,q;
Q-&gt;rear=Q-&gt;front;//先把尾结点提上来指向头结点 
p=Q-&gt;front-&gt;next;//把要删除的头结点的下一个给p 
Q-&gt;front-&gt;next=NULL;//把要头结点指向下一个的指针删除掉 
while(p)//一直到最后一个结点都释放掉 
{
     q=p;
     p=p-&gt;next;
     free(q);
}
return OK;
}

/* 若Q为空队列,则返回TRUE,否则返回FALSE */
Status QueueEmpty(LinkQueue Q)
{ 
if(Q.front==Q.rear)//指针相等就是空队列 ，也就是都指向头结点，注意头结点不放数据 
    return TRUE;
else
    return FALSE;
}

/* 求队列的长度 */
int QueueLength(LinkQueue Q)
{ 
int i=0;
QueuePtr p;
p=Q.front;
while(Q.rear!=p)
{
     i++;//用于计数 
     p=p-&gt;next;//指针向后 
}
return i;
}

/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */
Status GetHead(LinkQueue Q,QElemType *e)
{ 
QueuePtr p;
if(Q.front==Q.rear)//先判断 
    return ERROR;
p=Q.front-&gt;next;
*e=p-&gt;data;
return OK;
}


/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q,QElemType e)
{ 
QueuePtr s=(QueuePtr)malloc(sizeof(QNode));
if(!s) /* 存储分配失败 */
    exit(OVERFLOW);
s-&gt;data=e;//先设置要插入的结点的数据域 
s-&gt;next=NULL;//把这个结点的指针置为空 
Q-&gt;rear-&gt;next=s;    /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
Q-&gt;rear=s;        /* 把当前的s设置为队尾结点，rear指向s，见图中② */
return OK;
}

/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回    ERROR */
Status DeQueue(LinkQueue *Q,QElemType *e)//实际上删除的    队头元素是头结点的下一个！！！ 
{
QueuePtr p;
if(Q-&gt;front==Q-&gt;rear)
    return ERROR;
p=Q-&gt;front-&gt;next;        /* 将欲删除的队头结点暂存给p，见图中① */
*e=p-&gt;data;                /* 将欲删除的队头结点的值赋值给e */
Q-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */
//上面的语句相当于指针跳过去了 
if(Q-&gt;rear==p)        /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */
    Q-&gt;rear=Q-&gt;front;
free(p);
return OK;
}

/* 从队头到队尾依次对队列Q中每个元素输出 */
Status QueueTraverse(LinkQueue Q)
{
QueuePtr p;
p=Q.front-&gt;next;
while(p)
{
     visit(p-&gt;data);
     p=p-&gt;next;
}
printf(&quot;\n&quot;);
return OK;
}

int main()
{
int i;
QElemType d;
LinkQueue q;
i=InitQueue(&amp;q);
if(i)
    printf(&quot;成功地构造了一个空队列!\n&quot;);
printf(&quot;是否空队列？%d(1:空 0:否)  &quot;,QueueEmpty(q));
printf(&quot;队列的长度为%d\n&quot;,QueueLength(q));
EnQueue(&amp;q,-5);
EnQueue(&amp;q,5);
EnQueue(&amp;q,10);
printf(&quot;插入3个元素(-5,5,10)后,队列的长度为%d\n&quot;,QueueLength(q));
printf(&quot;是否空队列？%d(1:空 0:否)  &quot;,QueueEmpty(q));
printf(&quot;队列的元素依次为：&quot;);
QueueTraverse(q);
i=GetHead(q,&amp;d);
if(i==OK)
 printf(&quot;队头元素是：%d\n&quot;,d);
DeQueue(&amp;q,&amp;d);
printf(&quot;删除了队头元素%d\n&quot;,d);
i=GetHead(q,&amp;d);
if(i==OK)
    printf(&quot;新的队头元素是：%d\n&quot;,d);
ClearQueue(&amp;q);
printf(&quot;清空队列后,q.front=%u q.rear=%u q.front-&gt;next=%u\n&quot;,q.front,q.rear,q.front-&gt;next);
DestroyQueue(&amp;q);
printf(&quot;销毁队列后,q.front=%u q.rear=%u\n&quot;,q.front, q.rear);

return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之栈</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88/</url>
    <content><![CDATA[<p>栈是一种后进先出（LIFO)的数据结构，下面是栈的顺序存储方式<a id="more"></a>  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType; 

//顺序栈结构
typedef struct{
SElemType data[MAXSIZE];
int top;
}SqStack; 

Status visit(SElemType c){
printf(&quot;%d &quot;,c);
return OK;
}

//构造一个空栈 
Status InitStack(SqStack *S){
S-&gt;top=-1;
return OK;
} 

//把S置为空栈
Status ClearStack(SqStack *S){
S-&gt;top=-1;
return OK;
} 

//判断是否为空栈
Status StackEmpty(SqStack S){
if(S.top==-1)
    return TRUE;
else 
    return FALSE;
} 

//返回栈的长度
int StackLength(SqStack S){
return S.top+1;
} 

//若栈不空，用e返回栈顶元素，并返回OK,否则返回ERROR
Status GetTop(SqStack S,SElemType *e){
if(S.top==-1)
    return ERROR;
else
    *e=S.data[S.top];
return OK; 
} 

//插入元素e为新的栈顶元素
Status Push(SqStack *S,SElemType e){
if(S-&gt;top==MAXSIZE-1)
{
    return ERROR;
}
S-&gt;top++;
S-&gt;data[S-&gt;top]=e;
return OK;
} 

//删除栈顶元素
Status Pop(SqStack *S,SElemType *e){
if(S-&gt;top==-1)
    return ERROR;
else{
    *e=S-&gt;data[S-&gt;top];
    S-&gt;top--;
return OK;     
} 
} 

//从栈底到栈顶以此对每一个元素进行显示
Status StackTraverse(SqStack S){
int i;
i=0;
while(i&lt;=S.top){
    visit(S.data[i++]);
}
printf(&quot;\n&quot;);
return OK; 
} 

int main(){
int j;
SqStack s;
int e;
if(InitStack(&amp;s)==OK)//判断一下更把握 
    for(j=1;j&lt;=10;j++)
        Push(&amp;s,j);
printf(&quot;栈中元素以此为： &quot;);
StackTraverse(s);
Pop(&amp;s,&amp;e);//e用来返回弹出的值
printf(&quot;弹出的栈顶元素为e=%d\n&quot;,e);
printf(&quot;栈是否空：%d(1:空 0:不空)\n&quot;,StackEmpty(s));
GetTop(s,&amp;e);
printf(&quot;栈顶元素为e=%d 栈的长度为%d\n&quot;,e,StackLength(s));
ClearStack(&amp;s);
printf(&quot;栈清空后，栈是否空：%d(:空 0:不空)&quot;,StackEmpty(s));
}</code></pre><p>下面是两个栈共享空间的情况：  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType; 

//两栈共享空间
typedef struct{
SElemType data[MAXSIZE];
int top1;
int top2;
}SqDoubleStack;

Status visit(SElemType c){
printf(&quot;%d &quot;,c);
return OK; 
}
//构造一个空栈
Status InitStack(SqDoubleStack *S){
S-&gt;top1=-1;
S-&gt;top2=MAXSIZE;
return OK; 
} 

//把S置为空栈；和上面的构造一个空栈代码是一样的 
Status ClearStack(SqDoubleStack *S){
S-&gt;top1=-1;
S-&gt;top2=MAXSIZE;
return OK;
} 

//判断是否为空栈;两个要都为空 
Status StackEmpty(SqDoubleStack S){
if(S.top1==-1&amp;&amp;S.top2==MAXSIZE)
    return TRUE;
else
    return FALSE;
} 

//返回元素个数，即栈长
int StackLength(SqDoubleStack S){
return (S.top1+1)+(MAXSIZE-S.top2);
} 

//插入元素，需要标记是往哪个里面push,只需要判断总的栈是否满 
Status Push(SqDoubleStack *S,SElemType e,int stackNumber){
if(S-&gt;top1+1==S-&gt;top2)
    return ERROR;
if(stackNumber==1)
    S-&gt;data[++S-&gt;top1]=e;
else if(stackNumber==2)
    S-&gt;data[--S-&gt;top2]=e;
return OK;
} 

//删除栈顶的元素，需要分别判断每个是否为空 
Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber){
if(stackNumber==1){
    if(S-&gt;top1==-1)
        return ERROR;
    *e=S-&gt;data[S-&gt;top1--];//相当于两个语句，一个是把栈顶元素返回，一个是指针指向前一个 
} 
else if(stackNumber==2){
    if(S-&gt;top2==MAXSIZE)
        return ERROR;
    *e=S-&gt;data[S-&gt;top2++];
} 
return OK;
} 

//从左往右输出每一个元素
Status StackTraverse(SqDoubleStack S){
int i;
i=0;
while(i&lt;=S.top1){
    visit(S.data[i++]);
}
i=S.top2;//中间空余部分不输出 
while(i&lt;MAXSIZE){//MAXSIZE实际上是最大的下标加1 
    visit(S.data[i++]);
}
printf(&quot;\n&quot;);
return OK; 
} 

int main(){
int j,e;
SqDoubleStack s;
if(InitStack(&amp;s)==OK){
    for(j=1;j&lt;=5;j++)
        Push(&amp;s,j,1);
    for(j=MAXSIZE;j&gt;=MAXSIZE-2;j--)
        Push(&amp;s,j,2);
}
printf(&quot;栈中的元素依次为：&quot;);
StackTraverse(s);
printf(&quot;当前栈中元素有：%d\n&quot;,StackLength(s));

Pop(&amp;s,&amp;e,2);
printf(&quot;弹出的栈顶元素 e=%d\n&quot;,e);
printf(&quot;栈空否：%d(1:空 0:否)\n&quot;,StackEmpty(s));

for(j=6;j&lt;=MAXSIZE-2;j++)
    Push(&amp;s,j,1);

printf(&quot;栈中的元素依次为：&quot;);
StackTraverse(s);

printf(&quot;栈满否: %d(1:否 0:满)\n&quot;,Push(&amp;s,100,1));

ClearStack(&amp;s);
printf(&quot;清空栈后，栈空否：%d(1:空 0:否)\n&quot;,StackEmpty(s));        
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之线性表</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表是一种最基本的数据结构，下面是线性表的顺序存储方式（以下代码均参考《大话数据结构》，运行环境dev c++5.11）<a id="more"></a>  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define MAXSIZE 100
typedef int ElementType;
typedef struct LNode *List;
struct LNode{
ElementType Data[MAXSIZE];
int Last;
}; 
List L;

List MakeEmpty();
int Find(ElementType X,List L);
void Insert(ElementType X,int i,List L);
void Delete(int i,List L);
ElementType FindKth(int K,List L);

//初始化
List MakeEmpty(){
List L;
L=(List)malloc(sizeof(struct LNode));
L-&gt;Last=-1;
return L;
}
//按值查找 
int Find(ElementType X,List L){
int i=0;
while(i&lt;=L-&gt;Last&amp;&amp;L-&gt;Data[i]!=X)
    i++;
if(L-&gt;Last&lt;i)
    return -1;
    else 
    return i;
}

//插入,下面的为头插法 
void Insert(ElementType X,int i,List L){
int j;
if(L-&gt;Last==MAXSIZE-1){
    printf(&quot;表满&quot;);
    return;
}
if(i&lt;0||L-&gt;Last+1&lt;i){
    printf(&quot;位置不合法&quot;);
    return; 
}
for(j=L-&gt;Last;j&gt;=i;j--)
    L-&gt;Data[j+1]=L-&gt;Data[j];
    L-&gt;Data[i]=X;
    L-&gt;Last++;
    return;
} 

void Delete(int i,List L){
int j;
if(i&lt;0||L-&gt;Last&lt;i){
    printf(&quot;L-&gt;Data[%d]不存在元素&quot;,i);
    return;
}
for(j=i;j&lt;L-&gt;Last;j++)//删除第i个元素，实际上对应的下标是i-1 
    L-&gt;Data[j-1]=L-&gt;Data[j];
    L-&gt;Last--;
    return; 
}
ElementType FindKth(int K,List L){
if(K&lt;0||L-&gt;Last&lt;K){
    printf(&quot;L-&gt;Data[%d]不存在元素&quot;,K);
    return;
}
return L-&gt;Data[K];
}
int Length(List L){
return L-&gt;Last+1;
}
int main(){
int i=0;
L=MakeEmpty();
Insert(11,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入11\n&quot;);
Insert(25,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入25\n&quot;);
Insert(33,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入33\n&quot;);
Insert(77,0,L);
printf(&quot;在线性表L-&gt;Data[0]插入77\n&quot;);
printf(&quot;此时线性表为；&quot;);
for(i=0;i&lt;Length(L);i++)
    printf(&quot;%d&quot;,L-&gt;Data[i]);
printf(&quot;\n&quot;);
printf(&quot;查找值为12的下标为：%d\n&quot;,Find(12,L));
printf(&quot;下标为3的线性表的值是：%d\n&quot;,FindKth(3,L));
Delete(2,L);
printf(&quot;删除下标为2的元素\n&quot;); 
Delete(2,L);
printf(&quot;删除下标为2的元素\n&quot;);  
    printf(&quot;此时线性表为；&quot;);
for(i=0;i&lt;Length(L);i++)
    printf(&quot;%d&quot;,L-&gt;Data[i]);
printf(&quot;\n&quot;);
return 0;
}  </code></pre><p>以下是线性表的链式存储结构  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
typedef int ElementType;
typedef struct LNode *List;
struct LNode{
ElementType Data;
List Next;
};
List L;
List MakeEmpty();
int Length(List);
List FindfKth(int K,List L);
List Find(ElementType X,List L);
List Insert(ElementType X,int i,List L);
List Delete(int i,List L);
void Print(List L);

List MakeEmpty(){
List L=(List)malloc(sizeof(struct LNode));
L=NULL;
return L;
}

int Length(List L){
List p=L;
int len=0;
while(p){
    p=p-&gt;Next;
    len++;
}
return len;
}
List FindKth(int K,List L){
List p=L;
int i=1;
while(p&amp;&amp;i&lt;K){
    p=p-&gt;Next;
    i++;
}
if(i==K)
    return p;
else
    return NULL;
}
List Find(ElementType X,List L){
List p=L;
while(p&amp;&amp;p-&gt;Data!=X)
    p=p-&gt;Next;
return p;
}
List Insert(ElementType X,int i,List L){
List p,s;
if(i==1){
    s=(List)malloc(sizeof(struct LNode));
    s-&gt;Data=X;
    s-&gt;Next=L;
    return s;
}
p=FindKth(i-1,L);
if(!p){
    printf(&quot;结点错误&quot;);
    return NULL; 
}else{
    s=(List)malloc(sizeof(struct LNode));
    s-&gt;Data=X;
    s-&gt;Next=p-&gt;Next;
    p-&gt;Next=s;
    return L;
}
}
List Delete(int i,List L){
List p,s;
if(i==1){
    s=L;
    if(L)
        L=L-&gt;Next;
    else
        return NULL;
    free(s);
    return L;
}
p=FindKth(i-1,L);
if(!p||!(p-&gt;Next)){
    printf(&quot;结点错误&quot;);
    return NULL; 
}else{
    s=p-&gt;Next;
    p-&gt;Next=s-&gt;Next;
    free(s);
    return L;
}
}
void Print(List L){
List t;
int flag=1;
printf(&quot;当前链表为：&quot;);
for(t=L;t;t=t-&gt;Next){
    printf(&quot;%d&quot;,t-&gt;Data);
    flag=0;
} if(flag)
    printf(&quot;NULL&quot;);
printf(&quot;\n&quot;);
}
int main(){
L=MakeEmpty();
Print(L);
L=Insert(11,1,L);
L=Insert(25,1,L);
L=Insert(32,1,L);
L=Insert(77,1,L);
Print(L);
printf(&quot;当前链表长度：%d\n&quot;,Length(L));
printf(&quot;当前链表中第二个结点的值是：%d\n&quot;,FindKth(2,L)-&gt;Data);
printf(&quot;查询22是否在该链表中：&quot;);
if(Find(22,L))
    printf(&quot;是\n&quot;);
else
    printf(&quot;否\n&quot;);
printf(&quot;查询33是否在该链表中：&quot;);
if(Find(33,L))
    printf(&quot;是\n&quot;);
else
    printf(&quot;否\n&quot;);
L=Delete(1,L);
L=Delete(3,L);
printf(&quot;------------删除后---------\n&quot;);
Print(L);
return 0; 

}</code></pre><p>以下是栈的链式存储结构  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;io.h&gt;
#include&lt;math.h&gt;
#include&lt;time.h&gt;

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20

typedef int Status;
typedef int SElemType;

//链栈的结构,也可参考线性表的链式存储，效果是一样的 
typedef struct StackNode{//定义结点 
SElemType data;
struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct {//定义一个栈 
LinkStackPtr top;//定义了一个指向结点的指针
int count; 
}LinkStack;

Status visit(SElemType c){
printf(&quot;%d &quot;, c);
return OK;
} 

//构造一个空栈
Status InitStack(LinkStack *S){
S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));
if(!S-&gt;top)
    return ERROR;
    S-&gt;top = NULL;
    S-&gt;count = 0;
    return OK;
} 

//把S置为空栈
Status ClearStack(LinkStack *S){
LinkStackPtr p, q;//定义两个指向结点的指针 
p = S-&gt;top;
while(p){
    q = p;
    p = p-&gt;next;
    free(q);
}
S-&gt;count = 0;
return OK; 
} 

//判断是否为空
Status StackEmpty(LinkStack S){
if(S.count == 0)
    return TRUE;
else 
    return FALSE;
} 

//返回栈的长度
int StackLength(LinkStack S){
return S.count; 
} 

//用e返回栈顶元素
Status GetTop(LinkStack S, SElemType *e){
if(S.top == NULL)
    return ERROR;
else
    *e = S.top-&gt;data;
return OK;
} 

//插入元素为e的栈顶元素
Status Push(LinkStack *S, SElemType e){
LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
s-&gt;data = e;
s-&gt;next = S-&gt;top;
S-&gt;top = s;
S-&gt;count++;
return OK;
} 

//删除栈顶的元素，并用e返回
Status Pop(LinkStack *S, SElemType *e){
LinkStackPtr p;//先找结点再删除 
if(StackEmpty(*S))
    return ERROR;
*e = S-&gt;top-&gt;data;
p = S-&gt;top;
S-&gt;top = S-&gt;top-&gt;next;
free(p);
S-&gt;count--;
return OK; 
} 

//从顶开始访问
Status StackTraverse(LinkStack S){
LinkStackPtr p;
p=S.top;
while(p){
    visit(p-&gt;data);
    p = p-&gt;next;
}
printf(&quot;\n&quot;);
return OK;
} 

int main(){
int j;
LinkStack s;
int e;
if(InitStack(&amp;s) == OK)
    for(j = 1; j &lt;= 10; j++)
        Push(&amp;s, j);
printf(&quot;栈中元素依次为: &quot;);
StackTraverse(s);
Pop(&amp;s, &amp;e);
printf(&quot;弹出栈顶元素 e = %d\n&quot;,e);
printf(&quot;栈空否: %d(1:空 0:否)\n&quot;,StackEmpty(s));
GetTop(s,&amp;e);
printf(&quot;栈顶元素 e = %d 栈的长度为%d\n&quot;, e,StackLength(s));
ClearStack(&amp;s);
printf(&quot;清空后，栈空否: %d(1:空 0:否)\n&quot;,StackEmpty(s));
return 0;
}  </code></pre><p>以下是斐波那契数列的两种计算方法，注意体会迭代和递归的含义，当使用递归的方法的时候，对计算机内存的占用是非常大的  </p>
<pre><code>#include&lt;stdio.h&gt;

int F(int i){
if(i &lt; 2)
    return i == 0 ? 0 : 1;
return F(i - 1) + F(i - 2); 
}
int main(){
int i;
int a[40];
printf(&quot;迭代显示斐波那契数列：\n&quot;);
a[0] = 0;
a[1] = 1;
printf(&quot;%d &quot;, a[0]);
printf(&quot;%d &quot;, a[1]);
for(i = 2; i &lt; 40; i++){
    a[i] = a[i - 1] + a[i -2];
    printf(&quot;%d &quot;, a[i]);
} 
printf(&quot;\n&quot;);

printf(&quot;递归显示斐波那契数列：\n&quot;);
for(i = 0; i &lt; 40; i++)
    printf(&quot;%d &quot;, F(i));
return 0;
} </code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级学习笔记（一）</title>
    <url>/2019/12/23/PAT%E4%B9%99%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>##开一篇文章记录一下学习PAT乙级过程中遇到的问题。</p>
<p>1.string中截取字符串函数s.substr(2,3),表示从s的下标为2的字符开始连续截取3个字符，其中2和3不能为变量<br>2.B1003 我要通过！map&lt;char,int&gt; mp,当使用mp[‘T’]访问时，返回的是字符T的个数；mp.size()返回的是映射的对数；<br>3.B1004 成绩排名。当输入中有空格的字符串时，可以直接使用cin&gt;&gt;name&gt;&gt;sum来输入，中间的间隔就是空格。输出空格时cout&lt;&lt;” “,双引号之间一定有空格。<a id="more"></a><br>4.B1005 继续3n+1猜想。vector<int> v是两个变长数值，做题时发生了段错误，应该改为vector<int> v[k]表示其中一个是固定长度的。认真体会最后的关于用flag标记来输出中间空格的方法。<br>5.B1006换个格式输出整数。思维不要僵化，用数组存储各个位的数字，用取余%和整除/。<br>6.B1007素数对猜想。记住isprime函数的书写方式  </int></int></p>
<pre><code>bool isprime(int a){
for(int i=2;i*i&lt;=a;i++)
    if(a%i==0) return false;
return true;
}  </code></pre><p>7.B1008数组元素循环右移。使用vector时必须要添加相应的头文件；vector<int> v(N)注意是小括号，当使用[]时表示vector数组  </int></p>
<pre><code>vector&lt;int&gt; a ;      //声明一个int型向量a
vector&lt;int&gt; a(10) ;   //声明一个初始大小为10的向量
vector&lt;int&gt; a(10, 1) ;    //声明一个初始大小为10且初始值都为1的向量
vector&lt;int&gt; b(a) ;       //声明并用向量a初始化向量b
vector&lt;int&gt; b(a.begin(), a.begin()+3) ;//将a向量中从第0个到第2个(共3个)作为向量b的初始值  </code></pre><p>reverse的用法，注意<code>reverse(a,a+4)</code>表示翻转a[0]~a[3]；<br>8.B1010一元多项式求导。认真审题，输出中的0是1-1得0；可以用<code>while(cin&gt;&gt;a&gt;&gt;b)</code>来一直输入；同B1005体会用标记flag来输出空格的方法。<br>9.B1011A+B大于C。读题读3遍，看好细节；大整数运算时必须使用scanf和printf来输入输出；注意各个类型的取值范围  </p>
<pre><code>char -128 ~ +127 (1 Byte)
short -32767 ~ + 32768 (2 Bytes)
unsigned short 0 ~ 65536 (2 Bytes)
int -2147483648 ~ +2147483647 (4 Bytes) 2的31次幂
unsigned int 0 ~ 4294967295 (4 Bytes)
long == int
long long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)
double 1.7 * 10^308 (8 Bytes)
unsigned int 0～4294967295
long long的最大值：9223372036854775807
long long的最小值：-9223372036854775808
unsigned long long的最大值：184467440737095516  </code></pre><p>10.B1012数字分类。用scanf进行输入时，必须使用&amp;，否则会出现段错误，避免段错误有，大数组必须定义在全局变量，数组开小了，sort函数排序出问题。当n1-n2+n3-n4…时可以在每一层循环中加入符号变量s=s*（-1），使用头文件<cmath>中的pow（double n1，double n2）中注意double类型。当输出空格时可以循环printf（” “）,也可以直接输出printf，也可以直接printf(“N “);不存在和等于0不是相等的，所以A2的测试点8一直通不过，这道题简直太精辟了；<br>11.B1013数素数。按照每行10个的输出方式是用循环，注意前后顺序，判断和打印不能颠倒。代码背下来，：</cmath></p>
<pre><code>cnt=0;
for(int i=0;i&lt;v.size();i++){
    cnt++;
    if(cnt%10!=1) printf(&quot; &quot;);
    printf(&quot;%d&quot;,v[i]);
    if(cnt%10==0) printf(&quot;\n&quot;);
}  </code></pre><p>写判断是否为素数的bool函数，要注意括号的位置：  </p>
<pre><code>bool isprime(int a){
for(int i=2;i*i&lt;=a;i++)
    if (a%i==0) return false;
    return true;
}  </code></pre><p>12.B1014福尔摩斯的约会。星期隐含着要A~G。输出的星期要是字符串，时间要是整型。时间注意前面要补零。找到相同的字符串后要跳出。判断分钟的时候用for条件语句时可以使用中间两个条件，当使用if判断条件时，必须在一个if里面全包括如下，如果去掉<code>((s1[j]&gt;=&#39;A&#39;&amp;&amp;s1[j]&lt;=&#39;N&#39;)||isdigit(s1[j]))</code>  就会导致测试点1和2错误。</p>
<pre><code>for(int j=k+1;j&lt;s1.size()&amp;&amp;j&lt;s2.size();j++){
        if(s1[j]==s2[j]&amp;&amp;((s1[j]&gt;=&apos;A&apos;&amp;&amp;s1[j]&lt;=&apos;N&apos;)||isdigit(s1[j]))){
            if(isdigit(s1[j])) printf(&quot;%02d:&quot;,s1[j]-&apos;0&apos;);
            if(s1[j]&gt;=&apos;A&apos;&amp;&amp;s1[j]&lt;=&apos;N&apos;) printf(&quot;%d:&quot;,s1[j]-&apos;A&apos;+10);
            break;
        }
    }。  </code></pre><p>ctype中相关的函数（都是判断一个字符，不能判断字符串）以下结果如果是，就返回设定值，如果不是就返回原来的值，所以可以直接用，不用判断是否为大写字母等，如果是就tolower例子见B1029.    </p>
<pre><code>isalnum        是否为字母数字
isalpha        是否为字母
islower        是否为小写字母
isupper        是否为大写字母
isdigit        是否为数字
isxdigit    是否为16进制数字
iscntrl        是否为控制字符
isgraph        是否为图形字符（例如，空格、控制字符都不是）
isspace        是否为空格字符（包括制表符、回车符、换行符等）
isblank        是否为空白字符(C99/C++11新增)（包括水平制表符）
isprint        是否为可打印字符
ispunct        是否为标点
tolower        转换为小写
toupper        转换为大写</code></pre><p>这道题是一道文字游戏题，一定要认真审题后再下笔。  </p>
<p>##以下是乙级字符串处理的题：<br>1.B1021个位数统计。比较简单，vector<int> a[10]表示建立一个vector数组，a[0]~a[9]每一个都是一个vector容器，vector常见用法如下：    </int></p>
<pre><code>（1）a.assign(b.begin(), b.begin()+3); //b为向量，将b的0~2个元素构成的向量赋给a
（2）a.assign(4,2); //是a只含4个元素，且每个元素为2
（3）a.back(); //返回a的最后一个元素
（4）a.front(); //返回a的第一个元素
（5）a[i]; //返回a的第i个元素，当且仅当a[i]存在2013-12-07
（6）a.clear(); //清空a中的元素
（7）a.empty(); //判断a是否为空，空则返回ture,不空则返回false
（8）a.pop_back(); //删除a向量的最后一个元素
（9）a.erase(a.begin()+1,a.begin()+3); //删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）
（10）a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5
（11）a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4
（12）a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5
（13）a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8
（14）a.size(); //返回a中元素的个数；
（15）a.capacity(); //返回a在内存中总共可以容纳的元素个数
（16）a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
（17）a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
（18）a.reserve(100); //将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） 
（19）a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换
（20）a==b; //b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;  </code></pre><p>2.B1024科学技术法。寻找字符串中某一个字符的位置可以用<code>int i=0;while(s[i]!=&#39;E&#39;) i++;</code>。截取字符串和截取字符串转换为数字可以使用<code>string t=s.substr(1,i-1);//这是E前面的字符串 //int n=stoi(s.substr(i+1));//从i+1开始一直截取到最后//</code>.注意体会一个for循环中有两对条件的方法。<br>3.B1031查验身份证。当出现有判断时，先考虑是否采用函数，方程更简单。学会string每一位校验的时候，出现特殊情况怎么处理，将它剔除来单独处理。<code>int tmp=(s[17]==&#39;X&#39;) ? 10 : (s[17]-&#39;0&#39;);return b[num%11]==tmp;</code>这个返回写的太棒了。cin输入结束是以空格结束的。用flag来标记是否已经输出的方法继续学习。<br>4.B1048数字加密。A的长度大于B时，加不加0需要商讨。学会用字符串反转，<code>reverse(a.begin(),a.end());</code>a为字符串。学会使用append用法。<code>b.append(lena-lenb,&#39;0&#39;);</code>表示在字符b的结尾添加lena-lena长度的字符‘0’。使用append()添加文本常用方法:直接添加另一个完整的字符串:如str1.appen(str2);<br>添加另一个字符串的某一段子串:如str1.append(str2, 11, 7);<br>添加几个相同的字符:如str1.append(5, ‘.’);。用字符串来存储加密之后的结果<code>c+=str[(a[i]-&#39;0&#39;+b[i]-&#39;0&#39;)%13];</code>。定义字符数组用<code>char str[14]={&quot;0123456789JQK&quot;};</code>访问时可以直接使用str[n]来访问。<br>5.B1052卖个萌。break只能跳出一层循环，只能用于do~while,for,while语句，不能用于if语句，continue语句表示本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环，continue语句并没有使整个循环终止。<code>vector&lt;vector&lt;string&gt; &gt;v</code>。相当于二维可变长度数组。\表示转义字符，当想输出时必须再加上\即\。一行内有空格时必须使用<code>string s;getline(cin,s);</code>来读入一行。注意变量的定义位置，当把<code>vector&lt;string&gt; row;</code>定义在三层循环外面的时候会出现答案错误。中间读取字符的时候多用while语句，类似于一个双指针的操作，十分精彩。贴上大神的代码：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
vector&lt;vector&lt;string&gt; &gt; v;
for(int i=0;i&lt;3;i++){
    string s;
    getline(cin,s);
    int j=0,k=0;
    vector&lt;string&gt; row;
    while(j&lt;s.length()){
        if(s[j]==&apos;[&apos;){
            while(k++&lt;s.length()){
                if(s[k]==&apos;]&apos;){
                    row.push_back(s.substr(j+1,k-j-1));
                    break;
                }                    
            }
        }
        j++;
    }
    v.push_back(row);    
}
int n,a,b,c,d,e;
cin&gt;&gt;n;
for(int i=0;i&lt;n;i++){
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;
    if(a&gt;v[0].size()||b&gt;v[1].size()||c&gt;v[2].size()||d&gt;v[1].size()||e&gt;v[0].size()||a&lt;1||b&lt;1||c&lt;1||d&lt;1||e&lt;1){
        cout&lt;&lt;&quot;Are you kidding me? @\\/@&quot;&lt;&lt;endl;
        continue;
    }    
    cout&lt;&lt;v[0][a-1]&lt;&lt;&quot;(&quot;&lt;&lt;v[1][b-1]&lt;&lt;v[2][c-1]&lt;&lt;v[1][d-1]&lt;&lt;&quot;)&quot;&lt;&lt;v[0][e-1]&lt;&lt;endl;        
}
return 0;    
}    </code></pre><p>6.B1054求平均值。当输入有不同字符时，可以采用sscanf和sprintf来实现不同格式的输入输出<code>scanf(&quot;%s&quot;, a);sscanf(a,&quot;%lf&quot;,&amp;temp);sprintf(b,&quot;%.2f&quot;,temp);</code>其中a和b为字符数组。scanf结束的几种方式，空格或跳格，超过指定宽度，当非法输入。判断是否是非法字符的方式如下，用读入两位小数的字符数组长度和原来的字符数组长度长度来计算：方法很巧妙。    </p>
<pre><code>for(int j=0;j&lt;strlen(a);j++){
        if(a[j]!=b[j]) flag=1;
        if(flag||tmp&lt;-1000||tmp&gt;1000){
            printf(&quot;ERROR: %s is not a legal number\n&quot;,a);
            continue;
        }
        else{
            sum+=tmp;
            cnt++;
        }
    }  </code></pre><p>7.B1067试密码。PAToj中输入和输出可以一起输出，也可以单次输出。用getchar（）来吸收后面的换行”\n”。getline（cin，s)可以一次输入一整行。做好题目的分析，最后先打好流程图。<br>8.B1081检查密码。非空字符串也可以是空格，所以不能用cin来读入，需要使用<code>getline(cin,s)</code>来读入一行。第一行读入之后要求将最后回车键吸收掉<code>getchar()</code>.对于PAT考试，“对于有多组测试数据的输入，可以全部读入之后再输出，也可以处理一组测试数据就输出一组”，详见PAT运行说明。<br>9.B1084外观数列。当定义二维vector数组时，vector&lt;vector<int> &gt;v(45)后面尽量写上一个维的大小，否则容易容器下标越界。本题是采用双指针的方法，认真体会指针回溯的过程：  </int></p>
<pre><code>for(int i=0;i&lt;s.length();**i=j**){
        for(j=i;j&lt;s.length()&amp;&amp;s[j]==s[i];j++);
        t+=s[i]+to_string(j-i);    
    }  </code></pre><p>10.B1086就不告诉你。输出要是数字，使用stoi（）函数来实现。将数字反转的时候采用reverse（s.begin(),s.end())来实现。<br>11.B1058选择题。注意变量的命名方式一定要规范，绝对不能出现拼音。用vector&lt;set<char> &gt;rigtht(m)来存储每道题的正确答案可以保证一定是按照字母顺序输入的，同时使用st<char>来存储学生的答案。注意本题当中所使用的scanf（“ %c”，&amp;c）的用法，当以%c的形式来读入时是可以读入空格的。  </char></char></p>
<p>##以下是PAT乙级的逻辑题<br>1.B1084三人行。<code>double c=2*1.0/5，cout&lt;&lt;c;</code>等于0.4。<code>double c=2/5，cout&lt;&lt;c;</code>等于0。<code>double(2/5)</code>表示先进行除法，再进行强制类型转换。注意输出格式是一行内还是多行。本题的输出可以用一个函数：<br>    void print(double t) {<br>    if (m == t) printf(“ Ping”);<br>    else if (m &lt; t) printf(“ Cong”);<br>    else printf(“ Gai”);<br>    }<br>  注意abs(a-b)的使用，返回的是int类型，fabs返回的是double类型。一个两位数的倒着输出可以用<code>= i % 10 * 10 + i / 10;</code>同样的三位数也适用。<br>2.B1082射击比赛。可以采用<algorithm>下的MAX()来取最大值。本题是一道先假设最大和最小之后依次替换的典型题目，注意当n=0时，即最大和最小都是一个人的时候。<br>3.B1079延迟的回文数。大整数计算的写法：  </algorithm></p>
<pre><code>string add(string s1,string s2){
string s=s1;
int carry=0;
for(int i=s1.length()-1;i&gt;=0;i--){
    s[i]=(s1[i]-&apos;0&apos;+s2[i]-&apos;0&apos;+carry)%10+&apos;0&apos;;//字符串先变成数字进行运算再加上&apos;0&apos;变成字符。 
    carry=(s1[i]-&apos;0&apos;+s2[i]-&apos;0&apos;+carry)/10;
}
if(carry&gt;0) s=&apos;1&apos;+s;
return s;
}  </code></pre><p>注意reverse是一个函数的过程，不能够赋值，string s=reverse(a.begin(),a.end())这样的写法会出现问题；判断是否是回文数字的时候采用的是函数内写reverse()的方法。主函数当中如果出现return 0；就表示直接退出主函数，程序结束运行。<br>4.B1078字符串的压缩与解压。当压缩的时候也可以不采用双指针的方式，也可以采用单指针加上while循环的形式。注意解压的时候数字不一定是一位数，也可能是多位数，认真体会下面的统计位数的函数。  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
using namespace std;
void c(string s){
int j=0;
for(int i=0;i&lt;s.length();i++){
    int cnt=0;
    while(s[i]==s[i+1])
        i++,cnt++; 
    if(cnt!=0) cout&lt;&lt;cnt+1;
    cout&lt;&lt;s[i];  
}    
}
void d(string s){
for(int i=0;i&lt;s.length();i++){
    int sum=0;
    while(isdigit(s[i]))
        sum=sum*10+s[i++]-&apos;0&apos;;
    for(int j=0;j&lt;sum;j++)
        cout&lt;&lt;s[i];
    if(sum==0)
        cout&lt;&lt;s[i];
}
}
int main(){
string s,s0;
cin&gt;&gt;s0;
getchar();
getline(cin,s);
if(s0==&quot;C&quot;) c(s);
if(s0==&quot;D&quot;) d(s); 
return 0;    
}</code></pre><p>5.B1074宇宙无敌加法器。当从字符串最后一项是是s[s.length()-1]。注意“==”的书写。自定义函数当中变量的改变不会影响主函数中变量的改变。注意本道题中s（进制数字符）需要初始化，算法中直接赋值了。加法器定义的array必须定义在循环的外侧。加法器每一次只能够进1位。如何使用flag只标记一次，本题给出了if的方法。  </p>
<pre><code>for(int i = 0; i &lt; ans.size(); i++) {
if (ans[i] != &apos;0&apos; || flag == 1) {
flag = 1;
cout &lt;&lt; ans[i];
}
}</code></pre><p>当两个字符串需要补同样长的时候，除了使用，reverse（）反转再使用append（）在字符后加0之外，也可以采取本题的方式，很巧妙。  </p>
<pre><code>string ss1(s.length() - s1.length(), &apos;0&apos;);
 s1 = ss1 + s1;
string ss2(s.length() - s2.length(), &apos;0&apos;);
s2 = ss2 + s2;  </code></pre><p>6.B1060爱丁顿数。本题的大数组定义在了函数内部也没有超时，但是时间明显增加了很多，为了保险起见，大数组还是要开全局。数组的下标可以从1开始，不一定要从0开始，注意使用的时候也是从下标1开始的如sort。当书写sort的比较函数的时候，为了产生冲突，把比较函数定义为cmp1。本题有一个测试点没做出来，因为题意理解不明白…..<br>7.B1059C语言竞赛。注意模块化编程的思想，分步骤完成每一个功能。当出现要更改的时候，一定要把所有的地方都改到，本题就是把cout输出改为printf输出的时候有一个地方没改到导致测试点2通过不了。注意体会柳神代码中，使用set来标记是否输出的方法，set可以自动去掉查找的过程中重复的id插入：  </p>
<pre><code>if(ss.find(id) == ss.end()) //表示没有找到id值就插入
ss.insert(id);
} else {
printf(&quot;Checked\n&quot;);
continue;
}  </code></pre><p>8.B1063输出谱半径。注意printf函数中%md,%0md,%.mf这三种用法。<br>9.B1040有多少个PAT.本题如果暴力求解（就是使用三层for循环）会导致运算结果超时。本题的核心是先找A，找到A 就把结果更新，对于每一个A，它的左侧的P个数和右侧的T个数乘积就是这个A对应的PAT，所有结果相加就得到最后结果。这里有一个技巧是先遍历一遍字符串，求出T的个数，然后，每次判断如果为T 就把T个数减1.注意更新结果的时候每一次都对1000000007取余，结果更小。 </p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级学习笔记（二）</title>
    <url>/2019/12/23/PAT%E4%B9%99%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>##续接PAT乙级学习笔记（一）<br>##以下PAT乙级模拟题<br>1.B1053住房空置率。注意变量的命名方式，更加有助于解题和找bug。注意题目中输出一位小数点百分数的方式，（double）强制类型转换。  </p>
<pre><code>double mayvoid1=(double)mayvoid/n*100;
double isvoid1=(double)isvoid/n*100;
printf(&quot;%.1f%% %.1f%%&quot;,mayvoid1,isvoid1);  </code></pre><p>使用%%来输出一个%。使用\来输出一个,对于其他的转义字符需要\来输出，如printf(“\n”）将输出一个\n。<a id="more"></a><br>2.B1051复数乘法。当A或B在-0.005到+0.005之间时候，应该输出0.00而不应该输出-0.00，所以在输出的时候需要有一步判断。<br>3.B1050螺旋矩阵。这道题的思路不是很明确，不知道怎么样输出螺旋矩阵，所以做不出来。柳神给出来的思路很明确，需要借鉴参考学习。<br>4.B1046划拳。比较简单的一道题，5分钟就搞定了，注意书写变量的命名。<br>5.B1026程序运行时间。认真体会四舍五入时加上50的写法。注意当其中一项是0的时候应该输出00所以输出格式应该是%02d。输出控制符%.mf是保障精确到小数点后面几位，不是四舍五入，四舍五入应该用round（double）函数。<br>6.B1018锤子剪子布。题目较简单，注意变量命名的方式，一定要让自己能够看懂。对于每一个人胜利的存储可以参考柳神的方式，用数组，然后找出最大的下标。很巧妙。  </p>
<pre><code>int maxjia = jia[0] &gt;= jia[1] ? 0 : 1;
maxjia = jia[maxjia] &gt;= jia[2] ? maxjia : 2;
int maxyi = yi[0] &gt;= yi[1] ? 0 : 1;
maxyi = yi[maxyi] &gt;= yi[2] ? maxyi : 2;
char str[4] = {&quot;BCJ&quot;};
cout &lt;&lt; str[maxjia] &lt;&lt; &quot; &quot; &lt;&lt; str[maxyi];  </code></pre><p>7.B1016部分A+B。题目较简单，认为书写函数的方式要好于柳神的方法，代码也比较短。  </p>
<p>##以下PAT乙级数学题<br>1.B1056组合数的和。本题每个输入的数，相当于被加了N-1次，所以可以使用柳神的方式<code>sum += temp * 10 * (N - 1) + temp * (N - 1);</code>当然考场上如果想不起来，也可以使用两层for循环来写，也非常简单。<br>2.1049数列的片段和。编程不难，数学思想比较难想到，可以通过画图找规律，每一个数实际上都是被加了（n-i）*（n+1）次，通过在纸上演算可以得到。也可以参考柳神的代码用双指针的思想考虑，每个片段的头指针有i种选择，每个尾指针有n-1-i种选择。<br>3.B1019数字黑洞。这是一道做过的题，注意输入可能不是4位数，计算的过程中可能不是4位数，所以需要两次判断。<code>s.insert(0,4-s.length(),&#39;0&#39;);</code>这种插入的用法必须学会。另外当输入为6174的时候也需要进行循环，所以需要使用do语句，不能使用while语句。<br>##以下是PAT乙级HASH散列问题<br>1.B1083是否存在相等的数。将相减的数直接作为数组的下标记录个数就行，相对较简单。<br>2.B1047编程团体赛。本题注意柳神的scanf的应用，比我的方法简单太多了。<code>scanf(&quot;%d-%d %d&quot;, &amp;t, &amp;num, &amp;score);</code>我是采用读取字符串，然后判断的方法，简直蠢透了。附上我的代码  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt; 
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
using namespace std;
int main(){
int n,sum[1001]={0};
int maxnum,maxscore=0;
string s;
cin&gt;&gt;n;
getchar();
for(int i=0;i&lt;n;i++){
    int com,score=0;
    getline(cin,s);
    for(int j=0;j&lt;s.length();j++){
        if(s[j]==&apos;-&apos;){
            com=stoi(s.substr(0,j));
        }
        if(s[j]==&apos; &apos;){
            score=stoi(s.substr(j+1));
        }    
    }
    sum[com]+=score;
}
for(int i=1;i&lt;=1000;i++){
    if(sum[i]&gt;maxscore){ 
        maxscore=sum[i];
        maxnum=i;
    }
}
cout&lt;&lt;maxnum&lt;&lt;&quot; &quot;&lt;&lt;maxscore;
return 0;
}  </code></pre><p>附上柳神的代码：  </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, t, num, score;
 cin &gt;&gt; n;
 int team[1001] = {0};
 for (int i = 1; i &lt;= n; i++) {
 scanf(&quot;%d-%d %d&quot;, &amp;t, &amp;num, &amp;score);
 team[t] += score;
 }
 int max = 0;
 for (int i = 0; i &lt; 1001; i++) {
 if (team[max] &lt; team[i])
 max = i;
 }
 cout &lt;&lt; max &lt;&lt; &quot; &quot; &lt;&lt; team[max];
 return 0;
}  </code></pre><p>3.B1043输出PATest。我的思路是遍历每一个字符，然后如果字符是P就把他放在字符数组的第1个位置，对于下一个P就把它放在第七个位置，但是代码能力太弱，写出来的漏洞百出。以下附上柳神的代码以供学习：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt; 
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
using namespace std;
int main(){
int map[128]={0},c;\\一共128个ascii码。
while((c=cin.get())!=EOF) map[c]++;
while (map[&apos;P&apos;] &gt; 0 || map[&apos;A&apos;] &gt; 0 || map[&apos;T&apos;] &gt; 0 || map[&apos;e&apos;] &gt; 0 ||map[&apos;s&apos;] &gt; 0 || map[&apos;t&apos;] &gt; 0) {
    if (map[&apos;P&apos;]-- &gt; 0) cout &lt;&lt; &apos;P&apos;;
    if (map[&apos;A&apos;]-- &gt; 0) cout &lt;&lt; &apos;A&apos;;
    if (map[&apos;T&apos;]-- &gt; 0) cout &lt;&lt; &apos;T&apos;;
    if (map[&apos;e&apos;]-- &gt; 0) cout &lt;&lt; &apos;e&apos;;
    if (map[&apos;s&apos;]-- &gt; 0) cout &lt;&lt; &apos;s&apos;;
    if (map[&apos;t&apos;]-- &gt; 0) cout &lt;&lt; &apos;t&apos;;
 }
 return 0;
}  </code></pre><p>4.B1042字符统计。所有变量如果不直接输入都要初始化，这道题如果不初始化t，就会导致测试点2不通过。对于单个字符的hash散列可以使用它的ascii码作为键值。当要求有并列的时候从最小的输出时候，可以从遍历字母的最小的ascii开始。<br>5.B1039到底买不买。每一个珠子个数都存成a[s[i]-‘0’]的形式，a[]里面对应的不一定是这个字符的ascii码，不过不会影响最后的结果，不过像下面这样也是可以的s[i]默认选取其ascii码。柳神的代码采用了两个for循环，不易想到。  </p>
<pre><code>string s1,s2;
cin&gt;&gt;s1&gt;&gt;s2;
for(int i=0;i&lt;s2.length();i++){
    b[s2[i]]++;
}  </code></pre><p>6.B1038统计同成绩的学生的个数。相对简单，柳神的代码中使用了vector容器，我是用了数组保存成绩，注意数组的范围是a[101]。<br>7.B1033旧键盘打印。题目较难，可以参考柳神的代码，尤其注意string：：npos的用法，《算法笔记》p207有详细解释：  </p>
<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cctype&gt;
#include &lt;map&gt;
using namespace std;
int main(){
string bad,should;
getline(cin,bad);
getline(cin,should);
for(int i=0;i&lt;should.length();i++){
    if(bad.find(toupper(should[i]))!=string::npos) continue;
    if(isupper(should[i])&amp;&amp;bad.find(&apos;+&apos;)!=string::npos) continue;
    cout&lt;&lt;should[i];
} 
return 0;
}  </code></pre><p>8.B1029旧键盘。学会了柳神的find函数，对于判断字母还是大小写处理的还不是很好。  </p>
<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cctype&gt;
#include &lt;map&gt;
using namespace std;
int main(){
string s1,s2;
cin&gt;&gt;s1&gt;&gt;s2; 
int a[128]={0};
for(int i=0;i&lt;s1.length();i++){
    if(s2.find(s1[i])==string::npos&amp;&amp;a[s1[i]]==0){
        if(!isalpha(s1[i])){
            a[s1[i]]++;
            cout&lt;&lt;s1[i];
        }else{
            if(islower(s1[i])){
                a[s1[i]-32]++;
                a[s1[i]]++;
                s1[i]=toupper(s1[i]);
                cout&lt;&lt;s1[i];
            }
            else{
                a[s1[i]+32]++;
                a[s1[i]]++;
                cout&lt;&lt;s1[i];    
            }
        }
    } 
} 
return 0;
}    </code></pre><p>柳神的代码采用字符串相加的方式,真是妙！  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cctype&gt;
using namespace std;
int main() {
    string s1, s2, ans;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for (int i = 0; i &lt; s1.length(); i++)
    if (s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) ==string::npos)
    ans += toupper(s1[i]);
    cout &lt;&lt; ans;
 return 0;
}  </code></pre><p>##以下是PAT乙级STL-map题：<br>1.B1090危险品装箱。这道题比较难，参考了柳神的代码：</p>
<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
int n,k,t1,t2;
map&lt;int,vector&lt;int&gt; &gt; m;//每个数关联的数不是确定个，所以使用vector 
scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
for(int i=0;i&lt;n;i++){
    scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2);
    m[t1].push_back(t2);
    m[t2].push_back(t1);
}
while(k--){
    int cnt,flag=0,a[100000]={0};
    scanf(&quot;%d&quot;,&amp;cnt);
    vector&lt;int&gt; v(cnt);
    for(int i=0;i&lt;cnt;i++){
        scanf(&quot;%d&quot;,&amp;v[i]);
        a[v[i]]=1;//将每一个数都设置为1，散列 
    }
    for(int i=0;i&lt;v.size();i++)//从输入的第一个数开始遍历 
        for(int j=0;j&lt;m[v[i]].size();j++)//从每个数关联的数开始遍历 
        if(a[m[v[i]][j]]==1) flag=1;
        //m[v[i][j]]表示关联的第j个数，a[]表示关联的数存在 
    printf(&quot;%s\n&quot;,flag ? &quot;No&quot; : &quot;Yes&quot;); 
}
return 0;
}  </code></pre><p>2.B1085PAT单位排行。题目不会做，参考了柳神的代码。注意写代码的时候的代码风格，变量和运算符之间需要加空格，结束符，逗号等要靠在前面的变量。scanf（“%lf”，&amp;a）中间是字母l不是数字1.      </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node{
    string school;
int tws,ns;
};
bool cmp(node a,node b){
if(a.tws!=b.tws)
    return a.tws&gt;b.tws;
else if(a.ns!=b.ns)
    return a.ns&lt;b.ns;
else
    return a.school&lt;b.school;
}
int main() {
int n;
scanf(&quot;%d&quot;, &amp;n);
unordered_map&lt;string, int&gt; cnt;
unordered_map&lt;string, double&gt; sum;
for(int i = 0;i &lt; n; i++){
    string id,school;
    cin&gt;&gt;id;
    double score;
    scanf(&quot;%lf&quot;,&amp;score);
    cin&gt;&gt;school;
    for(int j=0;j&lt;school.length();j++)
        school[j]=tolower(school[j]);
    if(id[0]==&apos;B&apos;)
        score=score/1.5;
    else if(id[0]==&apos;T&apos;)
        score=score*1.5;
    sum[school]+=score;
    cnt[school]++;
} 
//下面是本题的重点
vector&lt;node&gt; ans;
for(auto it=cnt.begin();it!=cnt.end();it++)
    ans.push_back(node{it-&gt;first,(int)sum[it-&gt;first],cnt[it-&gt;first]});
sort(ans.begin(),ans.end(),cmp);
int rank=0,pres=-1;
printf(&quot;%d\n&quot;,(int)ans.size());
for(int i=0;i&lt;ans.size();i++){
    if(pres!=ans[i].tws) rank=i+1;
    pres=ans[i].tws;
    printf(&quot;%d &quot;,rank);
    cout&lt;&lt;ans[i].school;
    printf(&quot; %d %d\n&quot;,ans[i].tws,ans[i].ns);
} 
return 0;
}  </code></pre><p>3.B1080MOOC期中成绩。这道题和B1085很像，都使用了结构体，自己书写sort的cmp函数，我没做出来，参考的柳神的代码  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
    string name;
    int gp, gm, gf, g;
};
bool cmp(node a, node b){
    return a.g != b.g ? a.g &gt; b.g : a.name &lt; b.name;
}
map&lt;string, int&gt; idx;
int main(){
int p, m, n, score, cnt = 1;
scanf(&quot;%d %d %d&quot;,&amp;p, &amp;m, &amp;n);
vector&lt;node&gt; v, ans;
string s;
for(int i=0;i&lt;p;i++){
    cin &gt;&gt; s &gt;&gt; score;
    if(score&gt;=200) {
        v.push_back(node{s, score, -1, -1, 0});
        idx[s] = cnt++;//起到标记的作用 
    }        
}
for(int i=0; i&lt;m; i++){
    cin &gt;&gt; s &gt;&gt; score;
    if(idx[s] != 0) v[idx[s] - 1].gm = score;
}
for(int i=0; i&lt;n; i++){
    cin &gt;&gt; s &gt;&gt; score;
    if(idx[s]!= 0){
        int temp = idx[s] - 1;
        v[temp].gf = v[temp].g = score;
        if(v[temp].gm &gt; v[temp].gf)
            v[temp].g = int(v[temp].gm*0.4 + v[temp].gf*0.6 + 0.5);
    } 
}
for(int i = 0; i &lt; v.size(); i++)
    if(v[i].g &gt;= 60) ans.push_back(v[i]);
sort(ans.begin(), ans.end(), cmp);
for(int i = 0; i &lt; ans.size();i++)
    printf(&quot;%s %d %d %d %d\n&quot;,ans[i].name.c_str(), ans[i].gp, ans[i].gm, ans[i].gf, ans[i].g);    
return 0;
}</code></pre><p>注意输出时，因为名字使用的%s格式，所以输出的时候需要把.name的string格式变为.name.c_str格式，这一点需要注意。<br>4.B1069微博转发抽奖。本道题自己做出来了，但是思维逻辑有点混乱，参考了柳神的代码。用来做标记的flag可以设置成bool类型false，true。<br>5.B1063火星数字。参考了柳神的代码，柳神的代码书写真的很规范！  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
string a[13] = {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string b[13] = {&quot;####&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
string s;
int len;
void func1(int t) {
    if (t / 13) cout &lt;&lt; b[t / 13];
    if ((t / 13) &amp;&amp; (t % 13)) cout &lt;&lt; &quot; &quot;;
    if (t % 13 || t == 0) cout &lt;&lt; a[t % 13];
}
void func2() {
    int t1 = 0, t2 = 0;
    string s1 = s.substr(0, 3), s2;
    if (len &gt; 4) s2 = s.substr(4, 3);
    for (int j = 1; j &lt;= 12; j++) {
        if (s1 == a[j] || s2 == a[j]) t2 = j;
        if (s1 == b[j]) t1 = j;
}
cout &lt;&lt; t1 * 13 + t2;
}
int main() {
int n;
cin &gt;&gt; n;
getchar();
for (int i = 0; i &lt; n; i++) {
    getline(cin, s);
    len = s.length();
    if (s[0] &gt;= &apos;0&apos; &amp;&amp; s[0] &lt;= &apos;9&apos;)
        func1(stoi(s));
    else
        func2();
    cout &lt;&lt; endl;
}
return 0;
}    </code></pre><p>注意以下的代码风格的规范</p>
<pre><code>void fun1(int x, int y, int z);//良好 
void fun1 (int x,int y,int z); //不良好 

if (year &gt;= 200)    //良好 
if(year&gt;=200)       //不良好 
if ((a&gt;=b) &amp;&amp; (a&lt;=d)) //良好 
if(a&gt;=b&amp;&amp;a&lt;=d)       //不良好 

for (i=0; i&lt;10; i++)       //良好风格 
for(i=0;i&lt;10;i++)         //不良好风格 
for (i = 0; i &lt; 10; i++) //过多的空格 

x = a &lt; b ? a : b;  //良好
x=a&lt;b?a:b;          //不良好

int *x=&amp;b;   //良好
int * x=&amp; b; //不良好</code></pre><p>6.B1065单身狗。一定要注意“=”和“==”的区别，出现bug第一时间检查是不是这个出问题了！！！写代码的时候可以开大数组，少用STL等，会导致超时！！当输出有0的时候一定要注意输出格式！！这道题自己一点点的做出来了，用了两个多小时：下面是代码    </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;unordered_map&gt;
#include&lt;set&gt;
using namespace std;
int sign[100000];
int a[100000]={-1};
int b[100000]={-1};
int main(){
int n, m;
cin &gt;&gt; n;
set&lt;int&gt; ans;
for(int i = 0; i &lt; n; i++){
    int id1, id2;
    scanf(&quot;%d %d&quot;,&amp;id1,&amp;id2);
    a[id1] = id2;
    b[id2] = id1;
}
cin &gt;&gt; m;
int c[m];
for(int i = 0; i &lt; m; i++){
    scanf(&quot;%d&quot;,&amp;c[i]);
    if(a[c[i]] == -1 &amp;&amp; b[c[i]] == -1) ans.insert(c[i]);//说明是单身来了聚会 
    else sign[c[i]] = 1;//说明不是单身，但是他的另一半有没有来聚会，需要下面判断 
}
for(int i = 0; i &lt; m; i++){//判断不是单身的这些人，另一半来没来 
    if(sign[c[i]] == 1){
        int flag1 = 0;
        for(int j = 0; j &lt; m; j++){
            if(a[c[i]] == c[j] || b[c[i]] == c[j]) flag1 = 1;
        }
        if(flag1 == 0) ans.insert(c[i]);
    }
}
//将单身的按照顺序输出，注意输出空格的方法 
cout &lt;&lt; ans.size() &lt;&lt; endl;
int space = ans.size();
for(auto it = ans.begin(); it != ans.end(); it++){
    printf(&quot;%05d&quot;,*it);
    if(space-- &gt; 1) printf(&quot; &quot;);
}
return 0;
}  </code></pre><p>7.B1064朋友数。这道题比较简单，注意后面输出空格的方法。另外，stoi只能作用于字符串。 </p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>delay需要重复输入github密码的解决</title>
    <url>/2019/11/24/delay%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5github%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近开始更新博客时，发现每一次hexo d都需要重新输入密码，对照参考网上的解决办法，应该是本地库与远程库的连接为https（github支持SSH连接和https连接，免密码连接应该是<strong>SSH连接</strong>）：  </p>
<h4 id="1查看配置SSH-秘钥是否有效"><a href="#1查看配置SSH-秘钥是否有效" class="headerlink" title="1查看配置SSH 秘钥是否有效"></a>1查看配置SSH 秘钥是否有效</h4><p>先登录你的github，在setting目录下点击是否有公钥如下图，如果没有，需要重新生成新的公钥进行部署  <a id="more"></a></p>
<p><img src="/2019/11/24/delay%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5github%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3/ssh1%E6%88%AA%E5%9B%BE.png" alt></p>
<h4 id="2查看你的github博客仓库连接方式"><a href="#2查看你的github博客仓库连接方式" class="headerlink" title="2查看你的github博客仓库连接方式"></a>2查看你的github博客仓库连接方式</h4><p>在博客仓库的download下查看是否为SSH连接方式，如下图应该显示clone with ssh  </p>
<p><img src="/2019/11/24/delay%E9%9C%80%E8%A6%81%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5github%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3/ssh%E6%88%AA%E5%9B%BE.png" alt></p>
<h4 id="3查看hexo框架下的配置文件"><a href="#3查看hexo框架下的配置文件" class="headerlink" title="3查看hexo框架下的配置文件"></a>3查看hexo框架下的配置文件</h4><p>在hexo框架下查看配置文件config.yml，你的url应该从https改为ssh模式  </p>
<p><code>repo: www.github.com/Araik-77/Araik-77.github.io.git</code><br>应该改为下面这个<br><code>repo: git@github.com/Araik-77/Araik-77.github.io.git</code>  </p>
<p>至此，问题已经解决</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo github</tag>
      </tags>
  </entry>
  <entry>
    <title>MyFirstArticle</title>
    <url>/2019/11/11/MyFirstArticle/</url>
    <content><![CDATA[<p>这是我的第一篇博客，主要记录一下自己喜悦的心情。在2019年双11的凌晨3点钟，我终于折腾出自己的第一个博客。新的开始，加油！</p>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
